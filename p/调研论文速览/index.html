<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="更正学习行为后的第一次调研，之后在此基础上扩展第二次">
<title>调研论文速览</title>

<link rel='canonical' href='https://JiangZhiyu-1024.github.io/p/%E8%B0%83%E7%A0%94%E8%AE%BA%E6%96%87%E9%80%9F%E8%A7%88/'>

<link rel="stylesheet" href="/scss/style.min.819ac8ff77246a79c226a136382b6bcbe7c291f9fd1e0641c81bcb97ac7e8f89.css"><meta property='og:title' content="调研论文速览">
<meta property='og:description' content="更正学习行为后的第一次调研，之后在此基础上扩展第二次">
<meta property='og:url' content='https://JiangZhiyu-1024.github.io/p/%E8%B0%83%E7%A0%94%E8%AE%BA%E6%96%87%E9%80%9F%E8%A7%88/'>
<meta property='og:site_name' content='Zion Blaze'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2024-12-19T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2024-12-19T00:00:00&#43;00:00'/><meta property='og:image' content='https://JiangZhiyu-1024.github.io/p/%E8%B0%83%E7%A0%94%E8%AE%BA%E6%96%87%E9%80%9F%E8%A7%88/blossoms-8263945_1280.jpg' />
<meta name="twitter:title" content="调研论文速览">
<meta name="twitter:description" content="更正学习行为后的第一次调研，之后在此基础上扩展第二次"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://JiangZhiyu-1024.github.io/p/%E8%B0%83%E7%A0%94%E8%AE%BA%E6%96%87%E9%80%9F%E8%A7%88/blossoms-8263945_1280.jpg' />
    <link rel="shortcut icon" href="/favicon.ico" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/fireflies1_hu11714070595552142014.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🍥</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">Zion Blaze</a></h1>
            <h2 class="site-description">Welcome to my world!</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/CaiJimmy/hugo-theme-stack'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>友情链接</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#aero-softmax-only-llms-for-efficient--private-inference">AERO: SOFTMAX-ONLY LLMS FOR EFFICIENT  PRIVATE INFERENCE</a>
      <ol>
        <li><a href="#摘要"><strong>摘要</strong></a></li>
        <li><a href="#引言"><strong>引言</strong></a>
          <ol>
            <li><a href="#动机"><strong>动机</strong></a></li>
            <li><a href="#挑战"><strong>挑战</strong></a></li>
            <li><a href="#我们的技术与见解"><strong>我们的技术与见解</strong></a></li>
            <li><a href="#结果与意义"><strong>结果与意义</strong></a></li>
            <li><a href="#贡献"><strong>贡献</strong></a></li>
            <li><a href="#结论"><strong>结论</strong></a></li>
            <li><a href="#局限性"><strong>局限性</strong></a></li>
            <li><a href="#未来工作"><strong>未来工作</strong></a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#cipherdm-secure-three-party-inference-for--diffusion-model-sampling">CipherDM: Secure Three-Party Inference for  Diffusion Model Sampling</a>
      <ol>
        <li><a href="#摘要-1"><strong>摘要</strong></a></li>
        <li><a href="#引言-1"><strong>引言</strong></a></li>
      </ol>
    </li>
    <li><a href="#efficient-2pc-for-constant-round-secure--equality-testing-and-comparison">Efficient 2PC for Constant Round Secure  Equality Testing and Comparison</a></li>
    <li><a href="#摘要-2"><strong>摘要</strong></a></li>
    <li><a href="#centaur-bridging-the-impossible-trinity-of-privacy-efficiency-and-performance-in-privacy-preserving-transformer-inference">Centaur: Bridging the Impossible Trinity of Privacy, Efficiency, and Performance in Privacy-Preserving Transformer Inference</a>
      <ol>
        <li><a href="#摘要-3"><strong>摘要</strong></a></li>
        <li><a href="#引言-2"><strong>引言</strong></a></li>
      </ol>
    </li>
    <li><a href="#faster-lookup-table-evaluation-with-application-to--secure-llm-inference">Faster Lookup Table Evaluation with Application to  Secure LLM Inference</a>
      <ol>
        <li><a href="#摘要-4">摘要</a></li>
        <li><a href="#引言-3">引言</a></li>
        <li><a href="#我们的贡献">我们的贡献</a></li>
      </ol>
    </li>
    <li><a href="#input-reconstruction-attack-against-vertical-federated--large-language-models">Input Reconstruction Attack against Vertical Federated  Large Language Models</a>
      <ol>
        <li><a href="#摘要-5">摘要</a></li>
        <li><a href="#引言-4">引言</a></li>
        <li><a href="#相关工作">相关工作</a></li>
      </ol>
    </li>
    <li><a href="#mpc-minimized-secure-llm-inference">MPC-Minimized Secure LLM Inference</a>
      <ol>
        <li><a href="#摘要-6">摘要</a></li>
        <li><a href="#引言-5">引言</a></li>
        <li><a href="#利用开源模型">利用开源模型</a></li>
        <li><a href="#降低自注意力开销">降低自注意力开销</a></li>
        <li><a href="#相关工作-1">相关工作</a>
          <ol>
            <li><a href="#安全推理协议">安全推理协议</a></li>
            <li><a href="#mpc友好的近似">MPC友好的近似</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#nimbus-secure-and-efficient-two-party-inference-for-transformers">Nimbus: Secure and Efficient Two-Party Inference for Transformers</a>
      <ol>
        <li><a href="#摘要-7"><strong>摘要</strong></a></li>
        <li><a href="#翻译"><strong>翻译：</strong></a></li>
      </ol>
    </li>
    <li><a href="#no-free-lunch-theorem-for-privacy-preserving-llm-inference">No Free Lunch Theorem for Privacy-Preserving LLM Inference</a>
      <ol>
        <li><a href="#摘要-8"><strong>摘要</strong></a></li>
        <li><a href="#引言-6"><strong>引言</strong></a></li>
        <li><a href="#相关工作-2">相关工作</a>
          <ol>
            <li><a href="#llm推理中的隐私攻击">LLM推理中的隐私攻击</a></li>
            <li><a href="#llm推理中的隐私保护">LLM推理中的隐私保护</a></li>
            <li><a href="#llm推理中效用与隐私的权衡">LLM推理中效用与隐私的权衡</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#on-protecting-the-data-privacy-of-large-language--models-llms-a-survey">On Protecting the Data Privacy of Large Language  Models (LLMs): A Survey</a>
      <ol>
        <li><a href="#摘要-9">摘要</a></li>
        <li><a href="#引言-7">引言</a></li>
        <li><a href="#相关工作-3">相关工作</a>
          <ol>
            <li><a href="#a-llm评估的调查">A. LLM评估的调查</a></li>
          </ol>
        </li>
        <li><a href="#b-llm安全性和隐私的调查">B. LLM安全性和隐私的调查</a></li>
      </ol>
    </li>
    <li><a href="#privacy-in-large-language-models-attacks-defenses-and-future-directions">Privacy in Large Language Models: Attacks, Defenses and Future Directions</a>
      <ol>
        <li><a href="#引言-8">引言</a>
          <ol>
            <li><a href="#动机-1">动机</a></li>
            <li><a href="#范围与目标"><strong>范围与目标</strong></a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#privacy-preserving-prompt-engineering-a-survey">Privacy Preserving Prompt Engineering: A Survey</a>
      <ol>
        <li><a href="#摘要-10"><strong>摘要</strong></a></li>
        <li><a href="#引言-9"><strong>引言</strong></a></li>
      </ol>
    </li>
    <li><a href="#rhombus-fast-homomorphic-matrix-vector-multiplication-for-secure--two-party-inference">Rhombus: Fast Homomorphic Matrix-Vector Multiplication for Secure  Two-Party Inference</a>
      <ol>
        <li><a href="#摘要-11"><strong>摘要</strong></a></li>
        <li><a href="#引言-10"><strong>引言</strong></a></li>
      </ol>
    </li>
    <li><a href="#secformer-fast-and-accurate-privacy-preserving-inference-for-transformer-models-via-smpc">SecFormer: Fast and Accurate Privacy-Preserving Inference for Transformer Models via SMPC</a>
      <ol>
        <li><a href="#摘要-12"><strong>摘要</strong></a></li>
        <li><a href="#引言-11"><strong>引言</strong></a></li>
        <li><a href="#背景与相关工作"><strong>背景与相关工作</strong></a>
          <ol>
            <li><a href="#基于smpc的模型推理工作流程"><strong>基于SMPC的模型推理工作流程</strong></a></li>
            <li><a href="#基于smpc的transformer模型推理的主要瓶颈"><strong>基于SMPC的Transformer模型推理的主要瓶颈</strong></a></li>
            <li><a href="#transformer模型的高效ppi"><strong>Transformer模型的高效PPI</strong></a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#secure-transformer-inference-protocol">Secure Transformer Inference Protocol</a>
      <ol>
        <li><a href="#摘要-13"><strong>摘要</strong></a></li>
        <li><a href="#引言-12"><strong>引言</strong></a></li>
      </ol>
    </li>
    <li><a href="#truncformer--private-llm-inference-using-only-truncations">TRUNCFORMER:  PRIVATE LLM INFERENCE USING ONLY TRUNCATIONS</a>
      <ol>
        <li><a href="#摘要-14"><strong>摘要</strong></a></li>
        <li><a href="#引言-13"><strong>引言</strong></a></li>
        <li><a href="#我们的贡献-1"><strong>我们的贡献</strong></a></li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/%E8%B0%83%E7%A0%94%E8%AE%BA%E6%96%87%E9%80%9F%E8%A7%88/">
                <img src="/p/%E8%B0%83%E7%A0%94%E8%AE%BA%E6%96%87%E9%80%9F%E8%A7%88/blossoms-8263945_1280_hu7912349572123491330.jpg"
                        srcset="/p/%E8%B0%83%E7%A0%94%E8%AE%BA%E6%96%87%E9%80%9F%E8%A7%88/blossoms-8263945_1280_hu7912349572123491330.jpg 800w, /p/%E8%B0%83%E7%A0%94%E8%AE%BA%E6%96%87%E9%80%9F%E8%A7%88/blossoms-8263945_1280_hu15692557216601731514.jpg 1600w"
                        width="800" 
                        height="533" 
                        loading="lazy"
                        alt="Featured image of post 调研论文速览" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E8%B0%83%E7%A0%94/" >
                调研
            </a>
        
            <a href="/categories/llm%E5%AE%89%E5%85%A8%E6%8E%A8%E7%90%86/" >
                LLM安全推理
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/%E8%B0%83%E7%A0%94%E8%AE%BA%E6%96%87%E9%80%9F%E8%A7%88/">调研论文速览</a>
        </h2>
    
        
        <h3 class="article-subtitle">
            更正学习行为后的第一次调研，之后在此基础上扩展第二次
        </h3>
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2024-12-19</time>
            </div>
        

        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="调研论文速览">调研论文速览
</h1><p>今天ZD哥纠正了我学习方法上的错误，不要死扣细节，扣也白扣，别人辛辛苦苦那么久的成果怎么可能让我一天或者几天看懂，我方向出现了问题，我目前要调研，而不是每一篇都看懂，所以我现在要速览一下我能找到的所有相关论文，做个总结：</p>
<p>以下是新论文：</p>
<h2 id="aero-softmax-only-llms-for-efficient--private-inference">AERO: SOFTMAX-ONLY LLMS FOR EFFICIENT  PRIVATE INFERENCE
</h2><p>AERO: 用于高效私有推理的纯 Softmax 大语言模型</p>
<h3 id="摘要"><strong>摘要</strong>
</h3><p>专有语言模型的广泛使用引发了用户敏感数据的隐私问题，这凸显了私有推理（Private Inference, PI）的重要性，即在加密输入上直接进行推理。然而，目前的PI方法由于非线性操作的存在，面临极高的通信和延迟开销。在本文中，我们对基于Transformer的解码器语言模型中的非线性作用进行了全面分析。我们提出了AERO，这是一种四步架构优化框架，通过系统性地移除LayerNorm和GELU等非线性操作，并减少浮点运算（FLOPs）次数，优化现有的大语言模型（LLM）架构以实现高效PI。我们首次提出了专为高效PI设计的仅使用Softmax的架构，该架构大幅降低了FLOPs。此外，我们设计了一种新颖的熵正则化技术以提升Softmax-only模型的性能。AERO实现了最多4.23倍的通信开销减少和1.94倍的延迟降低。我们通过对比当前最先进的方法验证了AERO的有效性。</p>
<h3 id="引言"><strong>引言</strong>
</h3><h4 id="动机"><strong>动机</strong>
</h4><p>像ChatGPT这样的专有模型的广泛采用（Achiam等, 2023）显著提升了对用户敏感（提示）数据隐私保护的关注（Staab等, 2024；Mireshghallah等, 2024；Priyanshu等, 2023；Lauren和Knight, 2023），同时也需要防范旨在提取模型权重的攻击（Carlini等, 2024；Jovanović等, 2024）。这凸显了私有推理（Private Inference, PI）的必要性，其中用户将加密查询发送给服务提供商，而不暴露实际输入，推理直接在加密输入上进行，从而既保证输入隐私，又保护模型权重。</p>
<p>尽管PI方法具有良好的前景，但当前的PI方法由于极高的延迟和通信开销而在实际应用中仍然不可行——例如，在GPT-2模型（125M参数）上，使用128个输入Token生成一个输出Token需要8.2分钟，并消耗25.3 GB的通信量（图1）；在上下文大小扩展到512时，这一数值进一步增长到30.7分钟和145.2 GB（表7）。这些开销主要来源于Transformer架构的大语言模型（LLM）中对模型性能至关重要的非线性操作，如GELU、LayerNorm和Softmax（Hou等, 2023；Lu等, 2025）。</p>
<h4 id="挑战"><strong>挑战</strong>
</h4><p>当前针对Transformer架构模型（如ViT、BERT）的PI解决方案要么忽略了LayerNorm的成本（Li等, 2023a；Zeng等, 2023；Zhang等, 2023；Chen等, 2023），要么通过多项式函数近似非线性操作（Zimerman等, 2024；Dhyani等, 2024）。然而，多项式近似方法存在明显的局限性：其精度对数据特定的初始猜测非常敏感（Knott等, 2021），并且其有效性仅限于狭窄的输入范围（Zimerman等, 2024）。此外，为了提高近似精度而使用高阶多项式的网络往往难以训练和优化。</p>
<p>与此同时，为提升明文处理速度而设计的非线性减少方法对提升PI效率的潜力非常有限。例如，(He等, 2023；Noci等, 2023；He和Hofmann, 2024) 探索了设计无LayerNorm的LLM的架构启发式方法；然而，这些方法对激活函数选择（PI中的关键瓶颈）的广泛影响仍然鲜有研究。</p>
<h4 id="我们的技术与见解"><strong>我们的技术与见解</strong>
</h4><p>我们对基于Transformer的大语言模型（LLMs）中非线性操作的作用进行了深入分析，主要发现如下：</p>
<ol>
<li><strong>无LayerNorm的模型</strong>在前馈网络（FFN）中更倾向于使用ReLU而非GELU，这使其更适合私有推理（PI）。</li>
<li>在仅使用Softmax的模型中，训练不稳定性（表现为深层中的熵崩塌）可以通过对FFN权重进行归一化来避免，这在推理过程中避免了类似LayerNorm的非线性计算。</li>
</ol>
<p>我们还观察到一种现象，称为<strong>熵过载</strong>（entropic overload），即在使用GELU的无LayerNorm模型以及仅使用Softmax的模型中，注意力头（attention heads）以更高且接近最大值的熵值被卡住的比例显著增大。我们推测，熵过载会导致注意力头缺乏多样性和专业化，从而浪费了注意力头的表征能力，并导致性能下降，这在更高的困惑度（perplexity）中得以体现。</p>
<p>为缓解熵过载，我们提出了一种新颖的<strong>熵正则化</strong>技术，在训练过程中对极端熵值进行惩罚，从而避免偏离良好的熵分布。</p>
<h4 id="结果与意义"><strong>结果与意义</strong>
</h4><p>如图1所示，仅将GELU替换为ReLU，就使基础GPT-2模型的通信和延迟开销分别降低了2.68倍和1.35倍。进一步移除LayerNorm使这些收益分别提高到3.41倍和1.42倍。在Pythia模型中也观察到类似的改进（见图15）。</p>
<p>在仅使用Softmax的模型中，由于FFN仅执行线性变换，将多个线性层合并为一个单一线性层，可使FFN的FLOPs减少8倍，同时显著加速计算且不增加困惑度（见图1）。此外，我们的分析表明，Softmax-only模型中早期FFN的线性变换对于训练稳定性至关重要，而较深层的FFN则可以被裁剪，从而提供了进一步减少FLOPs的机会。</p>
<h4 id="贡献"><strong>贡献</strong>
</h4><p>我们的主要贡献如下：</p>
<ol>
<li>我们全面分析了基于Transformer的大语言模型中GELU和LayerNorm的非线性作用，通过使用Shannon熵研究它们对注意力得分分布的影响，为现有LLM架构的高效PI定制提供了洞见。</li>
<li>我们提出了AERO，一个四阶段优化框架，并设计了仅使用Softmax的模型，大幅减少了FLOPs，实现了最高1.94倍的速度提升和4.23倍的通信开销减少。</li>
<li>我们提出了一种新颖的熵正则化技术，用于提升Softmax-only模型的性能，在困惑度方面实现了6%-8%的改进。</li>
<li>我们在广泛的上下文长度（128、256、512）和模型深度（12层和18层）下，基于从CodeParrot Face和Languini数据集（Stanić等, 2023）中提取的1.2B至4.8B训练Tokens，对GPT-2和Pythia模型（Biderman等, 2023）进行了大量实验。</li>
</ol>
<h4 id="结论"><strong>结论</strong>
</h4><p>在本研究中，我们提出了AERO，一个四阶段设计框架，用于优化现有的大语言模型（LLM）架构，以实现高效的私有推理（PI）。我们设计了具有显著较低FLOPs的仅使用Softmax的架构，并提出了熵正则化技术以提升其性能。</p>
<h4 id="局限性"><strong>局限性</strong>
</h4><p>本研究主要关注于预训练性能，以困惑度（perplexity）作为主要评价指标，未包含对模型其他能力（如迁移学习或少样本学习）的实验评估。此外，所提出的仅使用Softmax的模型的有效性仅在参数量少于10亿的模型上进行了验证。</p>
<h4 id="未来工作"><strong>未来工作</strong>
</h4><p>未来将进一步进行更广泛的实验评估，包括将AERO适配于大规模模型的研究（详见附录H）。</p>
<h2 id="cipherdm-secure-three-party-inference-for--diffusion-model-sampling">CipherDM: Secure Three-Party Inference for  Diffusion Model Sampling
</h2><p>CipherDM: 用于扩散模型采样的安全三方推理</p>
<h3 id="摘要-1"><strong>摘要</strong>
</h3><p>扩散模型（Diffusion Models, DMs）在图像生成中实现了最先进的合成效果，并被应用于多个领域。然而，DMs 在使用过程中有时会严重侵犯用户隐私，因此隐私保护成为一个亟待解决的问题。直接在 DMs 中使用传统的隐私计算方案（如安全多方计算，MPC）会面临显著的计算和通信挑战。为了解决这些问题，我们提出了 <strong>CipherDM</strong>，这是第一个将 MPC 技术应用于 DMs 进行安全采样的新颖、通用框架，可广泛用于基于 DMs 的多种任务。</p>
<p>我们对采样延迟的组成部分进行了深入分析，找到耗时的环节，并设计了相应的安全 MPC 协议，用于计算包括 SoftMax、SiLU 和 Mish 在内的非线性激活函数。CipherDM 在常用架构（DDPM、DDIM）上使用 MNIST 数据集以及通过 diffusers 部署的 SD 模型进行了评估。与直接在 SPU 上实现的方式相比，我们的方法运行时间提高了约 <strong>1.084× 至 2.328×</strong>，通信成本降低了约 <strong>1.212× 至 1.791×</strong>。</p>
<p>代码地址：https://github.com/Zhaoxinxinzi/CipherDM</p>
<h3 id="引言-1"><strong>引言</strong>
</h3><p>以预训练的Transformer模型 [54] 和扩散模型（Diffusion Models, DMs）[19, 50, 53] 为代表的生成模型因其在文本和图像生成任务中的出色表现而备受关注。这些模型在深度学习即服务（Deep Learning as a Service, DLaaS）[51] 模式中被广泛使用。然而，使用此类服务时也带来了隐私问题。例如，在 ChatGPT [6] 和 Stable Diffusion (SD) [47] 的案例中，用户需要向服务提供商（如拥有大量计算资源的网站或应用程序）透露其私密的提示词或图像。另一种选择是，服务提供商将其专有的训练模型参数发布给用户，后者可以在本地进行推理或采样。</p>
<p>扩散模型在图像生成方面的卓越性能已在最近的多项研究中得以证明 [39, 44, 45, 47, 57]。然而，这些研究也引发了隐私问题 [39, 44, 47]。例如，Stable Diffusion 的基础性研究 [47] 指出，扩散模型使用的训练数据可能包含敏感或个人信息，而在数据收集过程中可能缺乏明确的用户同意。另一方面，Glide [39] 强调其模型能够生成虚假但高度逼真的图像，这些图像可能被用来制造令人信服的虚假信息或深度伪造（Deepfakes）。为了解决伦理问题，Glide 过滤掉了包含人物、暴力和仇恨符号的训练图像，从而降低了模型在问题场景中的误用风险。另一项研究 [44] 则通过在一个经过仔细筛选的数据集上训练模型，确保生成结果的美学质量和安全性。这些研究主要关注数据隐私和内容真实性的问题。尽管采取了措施来缓解安全性问题，但它们无法充分保证隐私信息的保护。</p>
<p>传统的采样阶段 [19, 27, 52, 60] 面临用户隐私提示词或图像泄露，以及提供商模型参数泄露的风险。对于用户而言，采样过程中的提示词和图像可能包含敏感信息，例如个人肖像、身份、习惯和职业。非法组织未经授权收集此类信息会对用户隐私构成重大威胁。类似地，对于模型提供商而言，扩散模型的训练过程需要大量的时间和资源投入，模型细节（包括参数和架构）的泄露会显著影响其利益和竞争优势。因此，在采样过程中优先保护隐私至关重要。</p>
<p>经典的隐私计算技术主要包括差分隐私（Differential Privacy, DP）[2, 8, 14, 24]、同态加密（Homomorphic Encryption, HE）[3, 4, 25, 49] 和安全多方计算（Secure Multiparty Computation, MPC）[10, 12, 31, 37, 38, 40]。虽然 DP 通常被认为是一种高效的方法，但它无法有效保证计算结果的精确性和准确性。此外，目前 DP 仍缺乏严格的安全性证明。HE 能够保持数据的保密性，但以较高的计算复杂性为代价。MPC 提供了一种解决方案，使得相互不信任的各方能够利用各自的私有输入协作计算某一函数，并确保只有函数的输出被揭示，任何一方都无法获得额外信息。该计算既保证了隐私又保证了正确性，既防止了恶意方获得除输出之外的信息，也确保诚实方不会接受错误的输出结果。一些研究 [13, 16, 22, 29, 59] 提出了基于 MPC 的解决方案，用于在 Transformer 模型上执行推理。然而，据我们所知，目前尚无基于 MPC 的方法用于扩散模型的安全采样。</p>
<p>我们推测，缺乏相关研究的主要原因可能包括：图像生成结果的隐私评估尚不明确，将扩散模型与 MPC 框架集成的难度较大，以及在隐私计算中采样效率较低。</p>
<p>基于上述观察，我们提出 <strong>CipherDM</strong>，这是首个基于 MPC 的推理框架，能够为扩散模型的采样提供严格的 MPC 保证。</p>
<h2 id="efficient-2pc-for-constant-round-secure--equality-testing-and-comparison">Efficient 2PC for Constant Round Secure  Equality Testing and Comparison
</h2><p>高效的二方安全协议（2PC）用于常数轮次的安全相等性测试和比较</p>
<h2 id="摘要-2"><strong>摘要</strong>
</h2><p>安全相等性测试和比较是两种重要的原语，广泛应用于许多安全计算场景中，如隐私保护的机器学习、私有集合交集、安全数据挖掘等。在这项工作中，我们提出了新的常数轮次二方安全协议（2PC）用于安全相等性测试和安全比较。我们的协议采用在线/离线范式设计。
理论上，对于32位整数，我们的相等性测试的在线通信仅为76比特，而我们的安全比较的成本仅为384比特。我们的基准测试结果显示：（i）我们的相等性测试比Guo等人（EUROCRYPT 2023）快9倍，比加扰电路方案（EMP-toolkit）快15倍；（ii）我们的安全比较协议比Guo等人（EUROCRYPT 2023）快3倍，比Rathee等人（CCS 2020）和加扰电路方案快6倍。</p>
<h2 id="centaur-bridging-the-impossible-trinity-of-privacy-efficiency-and-performance-in-privacy-preserving-transformer-inference">Centaur: Bridging the Impossible Trinity of Privacy, Efficiency, and Performance in Privacy-Preserving Transformer Inference
</h2><p>《Centaur：弥合隐私、效率和性能三者之间的难以实现的三位一体——隐私保护Transformer推理》</p>
<h3 id="摘要-3"><strong>摘要</strong>
</h3><p>随着像Transformer这样的预训练模型越来越多地部署在云平台上提供推理服务，围绕模型参数和推理数据的隐私问题日益突出。目前的隐私保护Transformer推理（PPTI）框架面临着隐私、效率和性能的“不可兼得三位一体”问题。例如，基于安全多方计算（SMPC）的解决方案提供了强有力的隐私保障，但带来了显著的推理开销和性能折衷。另一方面，使用随机置换的PPTI框架在推理效率上接近明文推理并保持准确的结果，但需要暴露一些模型参数和中间结果，从而可能导致严重的隐私泄露。单一技术难以解决这一“不可兼得三位一体”问题。为了解决这一挑战，我们提出了Centaur，一种新型的混合PPTI框架。与现有方法不同，Centaur通过随机置换保护模型参数，通过SMPC保护推理数据，利用Transformer模型的结构。通过设计一系列高效的隐私保护算法，Centaur结合了两种技术的优势，在PPTI中实现了隐私、效率和性能的更好平衡。我们在多种类型的Transformer模型和数据集上全面评估了Centaur的效果。实验结果表明，Centaur提供的隐私保护能力能够抵御各种现有的模型反演攻击方法。在性能和效率方面，Centaur不仅保持了与明文推理相同的性能，而且推理速度提高了5.0到30.4倍。</p>
<h3 id="引言-2"><strong>引言</strong>
</h3><p>Transformer模型（Vaswani et al., 2017; Devlin et al., 2019; Radford et al., 2019; Brown et al., 2020; Raffel et al., 2020; Liu et al., 2019; Lewis et al., 2020）正在迅速改变人类社会的运作方式。越来越多的Transformer模型，例如GPT-4（OpenAI, 2023）和Llama（Touvron et al., 2023），被部署在云平台上以提供高质量的服务，如聊天、虚拟助手和代码生成。然而，这种服务模式要求模型开发者和用户分别将模型参数和推理数据上传至云平台，从而带来了显著的隐私泄露风险。具体来说，模型参数通常代表了模型开发者的竞争优势，因此被视为个人资产。而推理数据也可能包含用户的私人信息，例如投资意图或健康状况。这些隐私风险严重阻碍了基于Transformer的大型语言模型（LLMs）在关键领域的应用。例如，在发现内部敏感代码泄露后，三星禁止其员工使用外部LLM服务。</p>
<p>大量研究（Chen et al., 2022; Li et al., 2023; Zeng et al., 2022; Zhang et al., 2023; Liang et al., 2023; Hao et al., 2022; Zheng et al., 2023; Gupta et al., 2023; Dong et al., 2023; Hou et al., 2023; Ding et al., 2023; Pang et al., 2023; Luo et al., 2024）已经出现，旨在解决Transformer推理过程中模型参数和推理数据的隐私问题。然而，这些方法通常在隐私、效率和性能之间存在权衡。例如，基于密码学的技术如安全多方计算（SMPC）（Shamir, 1979; Yao, 1986; Goldreich et al., 1987）因其理论上能够同时保护模型参数和推理数据的隐私而受到广泛关注。然而，直接将现有的SMPC协议应用于实现隐私保护Transformer推理（PPTI）可能导致显著的效率低下或性能下降。例如，基于SMPC的GPT-2BASE隐私保护推理生成单个Token需要超过25分钟（Hou et al., 2023）。这种低效主要源于使用SMPC进行隐私保护推理时，与明文推理相比，显著更高的通信开销，特别是在Transformer中的非线性操作（例如Softmax、GeLU和LayerNorm）时（详见第3节）。</p>
<p>为了解决这一问题，Li等人（Li et al., 2023）通过将Softmax和GeLU替换为一些SMPC友好的二次方程式，重新设计了Transformer模型，避免了非线性操作（如Softmax和GeLU中的erf、指数和最大值）的隐私保护计算。虽然这种激进的替换提高了PPTI的效率，但即使对修改后的模型进行重新训练或微调，模型性能仍会有所下降。Dong等人（Dong et al., 2023）尝试使用分段多项式逼近Transformer模型中的非线性操作。尽管这种方法能够保证模型的准确性，但使用SMPC计算分段多项式仍会带来显著的开销。Luo等人（Luo et al., 2024）整合了上述两种方法的优势，定制了一系列高效的隐私保护非线性算子，从而实现了更高效的PPTI。</p>
<p>尽管这些方法通过替代或近似技术提高了PPTI中非线性层的效率，但它们很少关注线性层中SMPC引发的开销。这导致原本在PPTI中通信开销较小的线性层，在这些优化后反而成为新的通信瓶颈。因此，基于SMPC的PPTI仍然效率低下。此外，通过替代提升效率往往会导致性能下降。</p>
<p>为了解决SMPC-based PPTI面临的效率和性能问题，Yuan等人（Yuan et al., 2023）提出了一种基于随机置换的方法来保护模型参数和推理数据的隐私。通过对置换后的模型参数和推理数据进行明文计算，基于置换的PPTI避免了SMPC带来的通信开销，并且由于未替代或近似任何非线性操作，其推理性能可以与明文推理相同。然而，为了确保推理过程的正确性，在推理过程中，Embedding层的参数以及部分中间结果将会被暴露，这带来了显著的隐私泄露风险（详见第3节）。</p>
<p>由此可见，现有基于单一隐私保护技术的PPTI工作只能满足隐私、效率和性能三元悖论中的一项或两项需求。使用单一技术突破PPTI中隐私、效率和性能的“不可调和三难”极具挑战性。为应对这一挑战，我们提出了一种名为<strong>Centaur</strong>的新型混合PPTI框架，其目标是通过充分利用不同隐私保护策略在模型参数和推理数据上的优势，更好地平衡这一“不可调和三难”（图1）。为实现这一目标，</p>
<p><strong>隐私性</strong>：Centaur 设计了一种新的 PPTI 流程，确保 PPTI 中的所有输入、输出和中间结果均处于随机置换状态或秘密共享状态。这为模型参数和推理数据的隐私提供了有效的保护（详见第 5.1 节和第 6 节）。</p>
<p><strong>效率</strong>：Centaur 通过将大量基于随机共享的隐私保护矩阵乘法转换为明文与随机共享之间的无通信隐私保护乘法，大幅提升了 PPTI 中线性层的效率。对于非线性层，Centaur 将基于 SMPC 的高开销隐私保护非线性操作转换为基于随机置换的明文操作，并设计了一系列高效的隐私保护非线性算法。通过对线性和非线性层的高效设计整合，Centaur 在推理速度上显著超越了现有的最先进基于 SMPC 的 PPTI 框架（Li et al., 2023；Dong et al., 2023；Luo et al., 2024）（详见第 5.2 节）。</p>
<p><strong>性能</strong>：Centaur 利用中间结果在秘密共享状态与随机置换状态之间的转换，实现了 Transformer 模型中非线性算子的隐私保护精确计算。因此，Centaur 无需对原始模型结构或参数进行任何修改，即可在 PPTI 中实现与明文推理相同的性能，且无需额外的再训练或微调（详见第 5.2 节）。</p>
<p>我们通过大量实验验证了 Centaur 的有效性（详见第 7 节）。具体而言，在隐私性方面，我们对多个模型和数据集进行了攻击实验，结果表明 Centaur 提供的隐私保护能够抵御现有的模型反演攻击方法。在效率和性能方面，我们在多种 Transformer 模型和数据集上测试了 Centaur，并与现有最先进的 PPTI 框架（Li et al., 2023；Dong et al., 2023；Luo et al., 2024）进行了比较。实验结果表明，与这些先进的 PPTI 框架相比，Centaur 不仅能够保持模型性能，还将推理速度提升了 5.0 至 30.4 倍。</p>
<h2 id="faster-lookup-table-evaluation-with-application-to--secure-llm-inference">Faster Lookup Table Evaluation with Application to  Secure LLM Inference
</h2><p>更快的查找表评估及其在安全大语言模型推理中的应用</p>
<h3 id="摘要-4">摘要
</h3><p>随着大语言模型（LLMs）的日益普及，用户隐私问题也愈发受到关注，因为用户提交用于推理的数据可能包含敏感信息。因此，通过安全两方计算（即安全LLM推理）运行LLMs已成为一个备受关注的热点。然而，LLMs中的许多操作（如Softmax和GELU）无法通过安全计算中的传统逻辑门来实现，而是需要利用查找表（LUTs）。这使得查找表成为安全LLM推理中的一个核心基础模块。本文提出了<strong>ROTL</strong>，一种用于查找表评估的安全两方协议。与目前最先进的查找表协议FLUTE（在Oakland &lsquo;23提出）相比，ROTL在总体性能上实现了最高11.6倍的加速，在在线性能上实现了最高155倍的加速。此外，ROTL支持算术共享（这是安全LLM推理所必需的），而FLUTE仅支持布尔共享。</p>
<p>ROTL的核心是一种用于秘密共享旋转的全新协议，该协议允许双方在不泄露旋转偏移的情况下生成旋转后表的加法共享。我们认为这一协议具有独立的研究价值。基于ROTL，我们设计了一种新的安全比较协议，与当前最先进的协议相比，其在线性能在带宽消耗上减少了2.4倍。为了支持布尔共享，我们还对FLUTE进行了优化，将其计算复杂度从 $O(l \cdot n^2) $降低到 $O(n \log n + l \cdot n)$，并将 $O(n \log n) $的计算转移到预处理阶段。因此，与FLUTE相比，该优化在总体性能上实现了最高10.8倍的加速，在在线性能上实现了最高962倍的加速。</p>
<h3 id="引言-3">引言
</h3><p>随着大语言模型（LLMs）的日益普及，用户隐私问题愈发受到关注，因为用户在推理阶段提供的数据可能包含敏感信息。因此，<strong>安全推理</strong> [10], [21], [20], [23], [30], [28], [17], [14] 已成为一个重要研究方向，其目标是在推理阶段实现如下目标：服务器 (S) 无法得知客户端 (C) 的输入，而客户端仅能获取推理结果，无法得知模型的其他信息。这可以被视为一种为模型推理量身定制的安全两方计算（2PC）协议。</p>
<p>然而，LLMs 中的许多操作（如 Softmax 和 GELU）无法通过 2PC 中的传统逻辑门进行计算，而是必须依赖查找表（LUT）。这使得 LUT 成为安全 LLM 推理中的一个核心基础模块。LUT 协议允许两方基于一个秘密共享的索引 i，从公共表 $x \in \mathbb{Z}_{2l}^n$ 中得出 $x_i$。通常会引入一个预处理阶段，用于准备一些昂贵且与输入无关的工作，以使在线阶段的计算更加高效。</p>
<p>LUT 评估最常见的方法基于 “1-out-of-n” OT（选择性传输）。具体而言，S 会为 C 的 n 个可能的输入共享生成对应的 LUT 输出，并用一个随机数对这些输出进行掩码（作为 S 的输出共享）。随后，C 使用 “1-out-of-n” OT 获取自己的输出共享。尽管这一协议在计算上是高效的，但在在线阶段需要传输整个查找表。</p>
<p>当前最先进的 LUT 协议（称为 FLUTE）通过将 LUT 表述转化为布尔表达式来避免传输整个查找表，然后将这些布尔表达式的电路表示为一个多输入内积进行评估 [4]。然而，FLUTE 在线阶段需要进行多输入 AND 门的评估，这带来了昂贵的计算成本。此外，FLUTE 的输入和输出仅支持布尔共享，而安全 LLM 推理需要算术共享，因为其中涉及大量矩阵乘法运算。为了用于安全 LLM 推理，FLUTE 必须结合布尔到算术（B2A）和算术到布尔（A2B）转换，而特别是 A2B 转换的代价非常高。</p>
<h3 id="我们的贡献">我们的贡献
</h3><p>在本文中，我们提出了 <strong>ROTL</strong>，一种比 FLUTE 显著更快且支持算术共享的 LUT 协议。ROTL 的核心思想是在预处理阶段，C 和 S 联合将查找表 x 向右旋转 s 个元素，旋转后的表和 s 的值都由 C 和 S 秘密共享。在在线阶段，C 和 S 可以简单地恢复 (i + s)，并输出旋转表中的第 (i + s) 个元素。</p>
<p>这一思路与 OTTT [19] 和 OP-LUT [9] 中的方法类似。然而，OTTT 和 OP-LUT 都需要评估昂贵的电路来旋转表：OTTT 对每一个可能的输入评估表示查找表的布尔电路，而 OP-LUT 可以被视为 GMW 协议的自然推广。与此不同，我们提出了一种显著更轻量化的查找表旋转协议。我们认识到，旋转是一种特殊的置换，因此利用了 Chase 等人提出的秘密共享置换协议 [5]，该协议已经非常轻量化，仅需 $n \log n$ 次随机 OT 操作。通过利用旋转的固有特性，我们将所需的随机 OT 数量显著减少至仅 $\log n$。此外，我们提出了一种方法，使得 C 和 S 可以旋转一个选择向量 $b \in \mathbb{Z}<em>2^n$，而不是直接旋转查找表 $x \in \mathbb{Z}</em>{2l}^n$。因此，我们使通信开销与 ll 无关。</p>
<p>虽然布尔共享在 LUT 中使用较少，但它们在布尔电路的评估中仍有应用。为了完整性，我们引入了另一种名为 <strong>FLUTE+</strong> 的 LUT 解决方案，针对布尔共享进行了优化。FLUTE+ 将 FLUTE 的计算复杂度从 O(l⋅n2)O(l \cdot n^2) 降低到 O(nlog⁡n+l⋅n)O(n \log n + l \cdot n)，并将 O(nlog⁡n)O(n \log n) 的计算转移到预处理阶段。</p>
<p>除了 LUT，<strong>安全比较</strong> 是安全 LLM 推理中的另一个关键基础模块，被广泛用于截断、Softmax 和 GELU 等操作中。基于 ROTL，我们引入了一种新的安全比较协议，将主要的开销转移至预处理阶段。与当前最先进的方法相比，我们的协议在在线性能方面实现了显著的加速（具体 xxx 倍速提升）。</p>
<p>我们总结了本文的主要贡献如下：</p>
<ul>
<li>提出了一种用于秘密共享旋转的新协议（详见第 III 节）；</li>
<li>提出了一种新的查找表（LUT）协议（称为 <strong>ROTL</strong>），其性能比 FLUTE 快至 155 倍，并支持算术共享（详见第 IV 节）；</li>
<li>对 FLUTE 进行了优化（称为 <strong>FLUTE+</strong>），实现了最高 962 倍的性能提升（详见第 V 节）；</li>
<li>提出了一种新的安全比较协议，与当前最先进的方法 [30] 相比，带宽需求减少了 2.4 倍（详见第 VI 节）；</li>
<li>将 ROTL 应用于安全大语言模型（LLM）推理（详见第 VII-E 节）；</li>
<li>提供了一个完整的实现以及全面的基准测试（详见第 VII 节）。</li>
</ul>
<h2 id="input-reconstruction-attack-against-vertical-federated--large-language-models">Input Reconstruction Attack against Vertical Federated  Large Language Models
</h2><p>基于纵向联邦大语言模型的输入重构攻击</p>
<h3 id="摘要-5">摘要
</h3><p>近年来，由于 ChatGPT 的出现，大语言模型（LLMs）受到了学术界和公众的广泛关注。尽管 LLMs 在各种任务中的文本生成能力令人惊叹，但隐私问题限制了其在实际业务中的应用。更具体而言，无论是用户的输入（用户将查询发送给模型托管服务器）还是模型本身（用户下载完整模型），在使用过程中都会被暴露。纵向联邦学习（VFL）是一种解决此类问题的有前景的方法。通过将模型分为底部部分和顶部部分，分别由用户和模型提供方维护，VFL 保护了用户输入和模型知识的隐私。然而，在本文中，我们证明了在 LLMs 中，VFL 无法保护用户输入，因为从中间嵌入中重构输入既简单又低成本。实验表明，即使使用商用 GPU，也能在仅 1 秒内重构出输入句子。我们还讨论了若干可能的解决方案，以增强纵向联邦 LLMs 的隐私保护能力。</p>
<h3 id="引言-4">引言
</h3><p>随着 ChatGPT [14] 的出现，大语言模型（LLMs）引起了公众和学术界的广泛关注。LLMs 在各种任务中表现出色，例如问答、阅读理解、文本摘要，甚至数学推理。然而，在实际应用中，LLMs 仍面临显著的隐私问题。例如，ChatGPT 的典型使用场景是用户将查询发送到 OpenAI 服务器，然后获取响应。在这种情况下，用户的查询完全暴露给了 LLM 提供商。如果查询包含敏感或有价值的信息，例如用户的个人信息或公司的机密数据，这是不可接受的。</p>
<p>另一种场景是用户下载完整的 LLM 模型并自行部署。虽然这种情况下保护了用户隐私，但模型却完全暴露给了用户。考虑到 LLM 是高度有价值的资产，这种方式会侵犯模型提供商的隐私。这里的核心问题在于，数据和模型分别由两个不同的参与方持有，双方的信息都不应被对方知晓。</p>
<p>一种解决此问题的方法是使用密码学技术。这些方法利用诸如多方计算协议、混淆电路和同态加密等密码学技术，来实现安全的神经网络推理或训练。尽管这些方法严格意义上完全保护了双方的隐私，但由于计算和通信开销过高，目前它们只能应用于相对简单的模型。一些前沿工作尝试使用密码学方法实现安全的 Transformer [8, 10, 4]，但即使在使用高性能服务器、理想的本地网络设置下，对于非常短的输入生成一个 token 也需要至少几分钟时间，这在实际应用中是不现实的。</p>
<p>一种替代隐私保护方法是纵向联邦学习（VFL）。VFL 的典型方法是分割学习（split learning），其过程如下：</p>
<ol>
<li>模型提供商通过某一层将模型划分为底部模型和顶部模型。然后将底部模型发送给用户。</li>
<li>在推理过程中，用户将其私有输入输入到底部模型中，得到隐藏嵌入（smashed data）。随后，他将隐藏嵌入发送给模型提供商，模型提供商将其输入顶部模型并得到模型输出，最后将输出发送给用户。</li>
</ol>
<p>因此，在分割学习中，仅隐藏嵌入和部分模型被暴露，这在一定程度上保护了双方的隐私。然而，需要注意的是，通过分割学习，用户查询的响应同样由模型提供商生成，这可能会泄露用户隐私。然而，本文关注的是用户输入的隐私，而非模型输出。</p>
<p>我们展示了攻击者如何能够利用隐藏嵌入和底部模型的参数轻松重构出用户的精确输入文本。具体而言，我们首先重构第一层中的词嵌入，然后计算重构的词嵌与底部模型中的实际词嵌的相似度，找出最相似的词。这种攻击非常高效，攻击者不需要任何额外的侧信息，仅需底部模型的参数即可。这样的攻击假设在模型提供商被攻破的情况下是现实的，因为攻击者可以获得完整的模型。</p>
<p>实验基于开源的 ChatGLM6B 模型进行。此外，我们还研究了在将隐藏嵌入发送给模型提供商之前添加噪声以增强输入隐私的方案。然而，实验结果表明，这种防御措施并不实际，因为模型性能也因此严重下降。</p>
<h3 id="相关工作">相关工作
</h3><p>虽然很少有研究探讨 LLM 中的输入重构问题，但从隐藏嵌入重构输入在深度学习，特别是纵向联邦学习（VFL）中已经是一个长期研究的问题。该问题可以分为两类：黑箱和白箱。在黑箱场景中，用于生成嵌入的底部模型是未知的，而在白箱场景中，攻击者拥有底部模型，包括其结构和参数值。</p>
<p>在黑箱场景中，一个基本的重构方法是训练一个重构模型，将隐藏嵌入作为输入，输出原始输入 [22, 9, 18]。其他方法包括训练一个生成器来进行反转 [9, 13]，以及训练替代模型和输入 [6]。尽管 [13] 也将反转攻击应用于语言模型，但它采用了黑箱设置，即攻击者对底部模型一无所知，但可以无限次查询模型。这要求攻击者训练一个生成模型来重构输入，过程非常耗时。相反，本文聚焦于白箱设置，因为它更加实用。</p>
<p>在白箱场景中，最直接的方法是直接优化输入，因为嵌入现在是可微分的 [9, 12, 18]。然而，[18] 中的作者直接优化了一维 one-hot 单词向量，采用了 Softmax 放松技术，这导致了次优性能，因为 one-hot 向量的维度太高。相反，我们首先优化单词嵌入，然后根据单词嵌入重构单词。</p>
<h2 id="mpc-minimized-secure-llm-inference">MPC-Minimized Secure LLM Inference
</h2><p>MPC 最小化的安全 LLM 推理</p>
<h3 id="摘要-6">摘要
</h3><p>许多基于大语言模型（LLM）的推理服务存在隐私问题，要么向服务方泄露用户的输入，要么向用户泄露专有的模型权重。安全推理通过多方计算（MPC）提供了一个解决方案，但由于MPC所带来的巨大开销，现有方法对于现代LLM工作负载仍然不可行。为了解决这一开销问题，我们提出了MARILL，一个框架，通过调整LLM微调过程，最大程度地减少MPC在安全推理过程中的使用。MARILL在微调过程中引入了高层架构变更，通过去除某些昂贵的操作并将其他操作移出MPC，同时不妥协安全性，从而显著减少了推理过程中MPC所需的操作数量。因此，MARILL生成的模型在所有安全推理协议中都更加高效，并且我们的方法与针对这些操作的MPC友好近似方法相辅相成。与标准微调相比，MARILL在不同MPC设置下的安全推理中实现了3.6−11.3倍的运行时提升和2.4−6.9倍的通信提升，同时通常在下游任务中保持超过90%的性能。</p>
<h3 id="引言-5">引言
</h3><p>基于Transformer的大型语言模型（LLMs）已经彻底改变了机器学习（ML）领域。自从ChatGPT发布以来，我们见证了大量专有LLM（如GPT-4 [57]、Claude 2 [2]、Bard [24]）和开源LLM（如Llama [69]、Mistral [34]）的发布，这些开源模型现已与专有模型竞争[11, 72, 76, 48]。最近，许多公司开始在特定领域数据上对这些模型进行微调，以提升其在下游任务（如聊天机器人、虚拟助手和协作助手）中的表现[57, 3, 15]。</p>
<p>然而，使用这些微调后的模型来支持面向用户的服务却引发了显著的隐私问题。一方面，这些微调模型的提供者不希望公开其模型的权重，因为这些模型通常是在专有数据上训练的，并代表了竞争优势。另一方面，用户不希望将自己的查询发送给这些提供者，因为查询可能包含敏感或专有信息（例如受知识产权保护的代码或用户数据）。事实上，一些企业已经禁止员工使用LLM服务，例如三星最近在一名员工意外将敏感代码泄露给ChatGPT后，禁止使用外部LLM服务[62]。</p>
<p>安全推理是解决这一挑战的有前景的解决方案，因为它可以通过多方计算（MPC）为双方提供隐私保护[22, 77]。关于安全推理的研究已有很多工作[56, 54, 61, 60, 70, 68, 26, 32]，这些工作提供了不同的性能和安全权衡，近期的研究集中在安全Transformer推理上[45, 73, 16, 50, 29, 25]。原则上，服务提供者可以使用这些最新的安全推理协议来支持其隐私保护服务。然而，尽管效率已取得巨大进展，这些协议对于今天的LLM仍然不切实际。例如，最先进的解决方案[25]要求在小型137M参数模型上生成第一个令牌时需要23秒和15.9GB的通信开销，对于一个典型的7B参数模型，运行时间和通信开销预计会增加到约6.5分钟和240GB，这是不可行的。</p>
<p>为了最小化这一开销，之前的研究集中于MPC中计算开销较大的低级操作，并提出了针对这些操作的MPC友好近似方法（第2节）。在本工作中，我们考虑了一种正交方法，旨在通过高层架构变更来最小化MPC开销。这种架构变更不会简化操作，而是减少了在MPC中需要的昂贵低级操作的数量。关键是，这一策略并不（必要）完全消除这些操作，而是将其移出MPC，不会妥协安全性，并且其成本相对较小。我们的工作首次探索了这种高层策略，我们称之为MPC最小化。我们通过微调实现这一目标，我们的关键见解是，微调如果能够根据安全推理精心定制，可以为MPC最小化开辟出显著的机会。</p>
<p>基于这一见解，我们提出了一个微调框架MARILL2，它对标准微调进行了战略性修改，并受到MPC独特特征的指导。通过MARILL微调后的模型具有以下特点：（i）MPC最小化，同时保持相同的安全性水平（第3节）；（ii）通过知识蒸馏，在ML性能上接近标准微调模型（第5节）。关键是，由于MARILL本质上是在MPC内压缩模型，生成的模型在所有安全推理协议中都显著更高效（第6.1节）。此外，如前所述，MARILL仅引入高层架构变更，这些变更与MPC友好的近似方法相辅相成。我们展示了将这些近似方法与MARILL结合使用时，效率进一步提高（第6.3节）。接下来，我们简要介绍我们的技术和它们在MPC中最小化的模型组件（加粗部分）：</p>
<h3 id="利用开源模型">利用开源模型
</h3><p>如前所述，开源LLM已变得更强大，并且现在能够与专有模型竞争[11, 72, 76, 48]。因此，出现了一种趋势，越来越多的服务提供商选择使用他们的私有数据集对这些开源模型进行微调，而不是从头开始训练自己的专有模型[3, 15]。标准的微调方法会使用私有数据更新所有模型权重，这要求整个模型都必须在MPC中运行，从而无法利用公开可用的预训练权重。因此，我们提出了两种微调策略，可以有效利用公共权重来最小化MPC的使用：</p>
<ul>
<li><strong>层冻结（Layer Freezing）（§ 5.1）</strong>：我们通过将微调更新（因此，私有权重）仅限于预训练模型的最终层，减少了需要在MPC中评估的Transformer层数量。我们采用这种严格的划分，因为交替使用私有层和公共层仍然需要在公共层中运行瓶颈操作，这需要在MPC中处理（§ 4），而仅仅修剪公共层会导致任务性能下降（§ 6.4）。</li>
<li><strong>低秩适配（Low-rank Adaptation，LoRA）（§ 5.2）</strong>：近年来，像LoRA [30]这样的参数高效微调技术表明，通过仅训练模型权重的一小部分，可以实现与标准微调相当的任务性能。尽管LoRA旨在加速微调过程，但我们展示了一种LoRA的新应用，表明它可以被重新用于减少MPC中矩阵乘法的维度——这是自然双方设置下以及其他MPC设置中解码（B）阶段的运行瓶颈（§ 5.2）。</li>
</ul>
<h3 id="降低自注意力开销">降低自注意力开销
</h3><p>我们分析了在不同MPC设置下LLM推理的成本配置，发现自注意力模块是最有效设置中的瓶颈（§ 5.3）。减少自注意力操作的标准方法是采用头修剪（head pruning）[53]。然而，我们必须修剪多达75%的头（及其对应的参数）才能取得显著的改进，但我们发现这会导致准确度大幅下降，即使在微调后也未能完全恢复（§ 6.4）。为了解决这一问题，我们引入了以下新技术：</p>
<ul>
<li><strong>头合并（Head-merging）（§ 5.3）</strong>：通过将多个头合并为一个，我们减少了MPC中需要的注意力头的数量，同时，也按比例增加了每个头的维度，以保留所有参数。虽然计算量（FLOPs）看似没有变化，但我们证明了头合并实际上在MPC中匹配了头修剪的性能（§ 6.4）。这是基于这样一个关键观察：在MPC中，成为瓶颈的自注意力操作仅与头的数量有关，而与头的维度无关。我们的实验表明，如果头合并得当，头合并比头修剪在任务性能上表现得更好（§ 6.4）。</li>
</ul>
<p>MARILL的端到端工作流程如图1所示。与标准微调相比，MARILL生成的模型在各种MPC设置的最先进安全推理框架中，运行时间提高了3.6至11.3倍，通信开销减少了2.4至6.9倍（§ 6.1）。我们在三种不同类型的任务上评估了MARILL的机器学习性能，即代码生成[8]、聊天机器人[82]和机器翻译[40]。在这些基准测试中，我们展示了MARILL通常能保持超过90%的标准微调性能（§ 6.2）。</p>
<h3 id="相关工作-1">相关工作
</h3><h4 id="安全推理协议">安全推理协议
</h4><p>在这项工作中，我们重点关注基于MPC（多方计算）的神经网络安全推理协议，该领域始于SecureML的开创性工作[56]。SecureML考虑了一个仅涉及服务提供者和客户的二方设置，并且在这一设置中经过许多后续工作[56, 37, 47, 54, 61, 60, 80, 31, 4, 27, 29, 50, 58]后，性能有了显著的提升。尽管如此，二方计算（2PC）仍然带来了非常大的开销。因此，随后的工作考虑了引入一个额外的帮助方的其他设置，如具有诚实多数的三方计算（3PC）[70, 41, 63, 55, 71, 16]和带有信任经销商的二方计算（2PC-Dealer）[39, 26, 32, 25]。其他一些工作则通过利用GPU加速[39, 68, 74, 32, 25]来加速安全推理协议。最近的工作[27, 29, 50, 58, 16, 73, 25, 6]在所有这些设置中，集中于安全的变压器推理，因为它们代表了当前AI工作负载的主流。我们的工作与这些协议是正交的，可以与它们中的任何一个一起加速安全推理（附录F）。</p>
<h4 id="mpc友好的近似">MPC友好的近似
</h4><p>一些工作[45, 56, 21, 19, 14, 9, 54, 51, 33, 59, 13, 12, 49, 42, 81]提出了针对非线性激活函数（如softmax和GeLU）的近似实现，使其更适合MPC。这些近似通常会导致模型性能的大幅下降。MPCFormer[45]提出了一种两阶段蒸馏过程来弥补这一差距。大多数这些工作[54, 33, 20, 59, 13, 12, 42, 49, 81]还使用了神经架构搜索（NAS），根据所需的精度级别，在同一网络中采用多个近似。</p>
<p>我们的工作与这些近似方法是互补的，因为我们对架构进行高层次的修改，而不是底层操作。我们在§ 6.3中展示了，这些近似方法可以与MARILL结合，以进一步提升性能。此外，MARILL与这些工作的两个关键区别在于：</p>
<ol>
<li>尽管这些工作输出的模型中所有权重都是私有的，但MARILL生成的模型混合了公共和私有权重；</li>
<li>基于NAS的工作中的模型架构依赖于私有训练数据，并泄露额外的信息，而MARILL是静态配置的，与训练数据无关。</li>
</ol>
<h2 id="nimbus-secure-and-efficient-two-party-inference-for-transformers">Nimbus: Secure and Efficient Two-Party Inference for Transformers
</h2><p>Nimbus：Transformers 安全高效的两方推理</p>
<h3 id="摘要-7"><strong>摘要</strong>
</h3><p>Transformer模型因其在机器学习任务中的强大能力而受到广泛关注。它们的广泛应用引发了关于推理过程中敏感信息泄露的潜在风险。然而，在应用于Transformer时，现有的基于安全双方计算（2PC）的方法在效率上存在两方面的限制：（1）线性层中的资源密集型矩阵乘法，和（2）复杂的非线性激活函数，如GELU和Softmax。本文提出了一种新的双方推理框架Nimbus，专为Transformer模型设计。在线性层方面，我们提出了一种新的2PC范式，并结合一种编码方法，基于外积思想安全地计算矩阵乘法，相比现有的最先进协议（SOTA），该方法在性能上提高了2.9×至12.5×。在非线性层方面，通过对输入分布的新观察，我们提出了一种低阶多项式近似方法，用于GELU和Softmax，这一方法相较于最先进的多项式近似提高了2.9×至4.0×，而与没有隐私保护的非2PC推理相比，我们方法的平均准确度损失为0.08%。与最先进的双方推理方法相比，Nimbus在不同网络设置下提高了BERTbase推理的端到端性能2.7×至4.7×。</p>
<h3 id="翻译"><strong>翻译：</strong>
</h3><p>引言
Transformer模型[36]在语言理解[19]、视觉任务[6]和聊天机器人[21]等多个机器学习任务中带来了显著的进展。随着Transformer模型处理越来越敏感的数据和任务，隐私问题成为部署中的一个重要关注点。例如，一家医院（客户端）希望使用另一家组织（服务器）的模型来增强其诊断能力。这对双方提出了隐私问题：医院要么必须上传其私密数据，要么组织需要将其专有模型发送给医院。</p>
<p>近期，基于安全的两方计算（2PC）[14, 26, 16, 29]的几项工作实现了隐私保护的安全两方推理。这些工作通过让客户端和服务器共同执行“加密”输入和模型的推理，使用包括同态加密（HE）[7]、加法秘密共享等密码学技术。客户端对模型一无所知，只知道推理结果，并且客户端的输入对服务器保密。</p>
<p>隐私保护伴随着大量的计算和通信开销，这是由于昂贵的密码学操作造成的。尽管现有的卷积神经网络的安全两方推理可以在几分钟内完成[8, 23, 18, 2, 34, 32, 17]，但是在Transformer模型上实现安全推理却更具挑战性，因为线性层中大量的矩阵乘法和复杂的非线性层。为了摊销线性层中HE的开销，许多工作[17, 14, 26]采用了窗口编码来模拟内积。然而，这种编码方法带来了HE密文的稀疏格式，导致冗余的通信和计算。非线性层的效率瓶颈在于如何安全地计算GELU和指数函数（包括Softmax）。之前的工作[5, 26]使用分段多项式来逼近这两个非线性函数。然而，为了保持精度，使用了高阶多项式和较大的定点精度，这导致了较大的通信开销和多轮计算。</p>
<p>本文提出了一种新的安全两方推理框架Nimbus，旨在解决上述效率瓶颈。具体来说，我们的贡献总结如下：</p>
<p>• 我们提出了一种客户端外积（COP）协议，以促进线性层的计算。我们的COP协议包含了两个关键创新。首先，模型权重的静态特性使得服务器可以在设置阶段将加密权重发送给客户端，从而消除了在线阶段的输入通信。其次，去除输入通信使得我们能够设计一种新颖的行级编码方案，通过外积实现同态矩阵乘法。这种编码进一步提高了同态矩阵乘法的效率，并为通信生成了紧凑的输出密文。</p>
<p>• 对于非线性层，我们提出了一个新的观察结果，即它们的输入分布呈现规律性。与之前假设均匀输入分布的逼近方法不同，我们的方法减少了分配给少见输入值的逼近预算。这使得我们能够使用低阶多项式和较少的片段来逼近非线性函数。此外，低阶多项式对定点误差的敏感性较低，使我们能够采用更小的环以提高效率。我们还提出了一种新协议，能够实现小环和大环之间的自由转换。因此，我们的方法在非线性层上取得了更好的性能，同时仅产生了平均0.08%的准确性损失。</p>
<p>• 我们使用流行的Transformer模型BERTbase在局域网（LAN）和广域网（WAN）设置下评估了Nimbus的性能。与最先进的工作BumbleBee[26]相比，我们在安全计算矩阵乘法（分别是GELU和Softmax）方面提高了2.9倍至12.5倍（分别是2.9倍至4.0倍）。结合所有优化，我们将安全两方推理的端到端性能提高了2.7倍至5.9倍，并减少了60%的通信成本。代码可在以下链接获取：https://github.com/secretflow/spu。</p>
<h2 id="no-free-lunch-theorem-for-privacy-preserving-llm-inference">No Free Lunch Theorem for Privacy-Preserving LLM Inference
</h2><h3 id="摘要-8"><strong>摘要</strong>
</h3><p>个人和企业在许多方面从大型语言模型（LLMs）中受益匪浅，包括PaLM、Gemini和ChatGPT等。例如，LLMs提高了生产力、降低了成本，并使我们能够专注于更有价值的任务。此外，LLMs具备了处理大量数据集、发现潜在模式，并提供推动技术和科学前沿的关键见解的能力。然而，LLMs也带来了隐私问题。用户与LLMs的互动可能会暴露他们的敏感个人或公司信息。缺乏强有力的隐私保障和法律框架可能会导致不当的数据处理或无理的侵犯，进而可能引发隐私侵犯和个人身份盗窃的风险。为了确保隐私，必须最小化共享提示与私密信息之间的依赖关系。虽然已经提出了各种随机化方法来保护提示的隐私，但与未保护的LLMs提示相比，这些方法可能会导致效用损失。因此，在实施有效保护机制时，必须评估隐私泄露风险与效用损失之间的平衡。本研究开发了一个推理隐私保护的大型语言模型（LLMs）的框架，并为研究隐私保护与效用之间的相互关系奠定了坚实的理论基础。核心观点通过一个定理加以总结，该定理被称为NFL（No-Free-Lunch）定理。</p>
<h3 id="引言-6"><strong>引言</strong>
</h3><p>复杂的大型语言模型的出现，包括PaLM [1]和ChatGPT [2]，为个人和企业带来了巨大的好处。这些模型能够帮助我们在从信息合成到生成新内容和数据分析等多种领域的工作中取得进展。通过这样做，它们提高了我们的生产力、降低了成本，并使我们摆脱了繁琐的工作，能够专注于更有价值的任务[3]。此外，LLMs还可以帮助生成创意、设计解决方案以及促进研究与开发。例如，在医疗保健、金融和科学等领域，LLMs能够分析大量数据，识别模式，并提供有价值的见解，推动技术和科学的突破与进展。尽管LLMs带来了巨大的好处，但它们也引发了隐私问题。当用户与LLMs互动时，他们的查询可能涉及机密的个人或公司信息，这些信息会暴露给LLMs的提供方。如果用户的查询没有得到充分保护，而LLM供应商也没有得到有效监管，用户数据可能会被滥用或被未经授权的人访问，从而导致身份盗窃或其他隐私侵犯。尤其考虑到共享给AI聊天机器人或代理的敏感信息（如财务详情或健康相关讨论），这一点更加令人担忧。因此，在对LLMs进行推理时，保护隐私显得尤为重要。</p>
<p>本研究聚焦于一种典型的LLM推理设置，其中LLM是黑箱的，其架构、模型参数和推理细节被隐藏在商业API和用户界面中。基于此，保护提示隐私的一种自然方法是对提示进行随机化。为解决这一问题，已有若干随机化技术[4, 5, 6]被提出，并在减少由暴露提示引发的隐私泄露方面显示了实证效果。然而，与未加保护的LLM提示相比，这些方法不可避免地会带来一定程度的效用损失。此外，现有研究缺乏必要的理论分析来量化效用损失和隐私泄露之间的折衷。减少私人信息暴露与效用损失之间的矛盾促使我们探索一个研究问题：“从理论上讲，是否有可能开发出某些保护方法，在提示LLM时既能最小化私人信息的暴露，又能尽量减少效用损失？”我们在提出的隐私保护LLM推理框架中的定理4.4中总结了这一主要发现，提出了对这一问题的反论证。我们将其命名为“无免费午餐定理”（No-Free-Lunch Theorem）。</p>
<p>另一项相关研究[7]也提出了一个定理，试图解决效用与隐私之间的平衡。然而，该研究的范围主要集中在横向联邦学习中的模型训练，其中隐私泄露是基于在客户端和服务器之间传输的模型梯度来定义的。相比之下，我们的工作集中于LLM推理，其中涉及提示和LLM输出的交互发生在客户端和服务器之间，如第3节所述，我们将隐私泄露定义为对手从受保护的输入中推断原始输入的程度。这些不同的隐私泄露定义为分析效用与私人信息之间的平衡提供了新的理论视角。</p>
<p>本研究的贡献总结如下：
• 提出了一个旨在保护隐私的LLM推理框架，其中我们为隐私泄露（在定义3.1中概述）和效用损失（在定义3.2中概述）提供了正式定义。此外，我们将隐私保护的LLM推理问题形式化为一个约束优化问题。
• 提出了一个针对隐私保护LLM推理的“无免费午餐定理”（如定理4.4所述），该定理提供了效用损失和隐私暴露之间折衷的定量特征。具体来说，它表明，效用减少和隐私暴露的加权总和有一个下界，该下界是特定问题所决定的常数，并且不为零，这意味着为了确保所需的隐私保护水平，必须牺牲一定程度的模型性能。</p>
<h3 id="相关工作-2">相关工作
</h3><p>在大语言模型（LLM）推理过程中，客户端和LLM服务器都有可能作为对手，危及彼此的隐私[8]。本研究关注一种情境，其中LLM服务器充当对手，通过分析客户端提供的提示推断出客户端的私人信息（见第3.1节）。本节简要回顾了现有关于隐私攻击、保护措施以及在大语言模型（LLM）推理领域中平衡保护隐私与保持效用的研究。</p>
<h4 id="llm推理中的隐私攻击">LLM推理中的隐私攻击
</h4><p>在LLM推理阶段，LLM服务器可能通过分析客户端发送的提示来推断客户端的私人信息。这可以通过从单一提示中推断隐私信息，或通过操控本无害的对话来诱导用户提供包含私人和敏感信息的提示来实现[9]。在此类情境中，已经概述了多种攻击策略。例如，服务器具备发起反转嵌入攻击的能力[10, 11, 12, 13]，旨在根据提供的嵌入重建原始提示。此外，服务器还可以利用这些攻击提取敏感信息，如种族、性别和年龄等[14, 15, 16, 17, 18]。此外，托管LLM的服务器可以利用其模型从修改后的版本中辨别客户端的原始提示[5, 9]。</p>
<h4 id="llm推理中的隐私保护">LLM推理中的隐私保护
</h4><p>安全多方计算（SMPC）和随机化是两种主流的保护机制，用于保护客户端的敏感信息隐私。SMPC通过多方协作计算一个函数，确保每个方的输入保持机密。在LLM的背景下，SMPC可以用于加密数据上的计算，从而确保没有单一方能够访问其他方的机密输入。这些方法的重点在于提升LLM架构和SMPC协议的效率，以最小化SMPC协议所带来的大量计算和通信开销[19, 20, 21, 22, 23, 24, 25]。尽管SMPC能够确保客户端数据的机密性，但它要求LLM与客户端紧密协作，这可能限制其应用于仅通过商业API访问的LLM。随机化是另一种隐私保护机制，它通过在提示的嵌入中加入随机噪声来保护提示的隐私。例如，InferDPT方法[5]利用差分隐私（DP）机制改变用户的输入文本，从而阻止恶意LLM服务器通过推断敏感用户信息进行窃听。在InferDPT系统的背景下，用户首先对输入中的词汇进行微小但语义一致的变化。然后，将此修改后的输入转发给LLM，LLM生成回复并将其反馈给用户。用户随后利用自己的预训练模型，通过结合初始输入和LLM的回复，产生最终输出。DP-OPT技术[26]则利用先进的深度语言网络（如DLN [27]所描述）在本地模型的指导下，自主优化输入提示。在这一过程中，DP-OPT实现了一种隐私保护聚合技术，以确保提示的机密性。在另一项研究中，Staab等人[9]探讨了文本匿名化技术在保护用户数据隐私中的应用，并通过实证证据得出结论，单独采用这些方法不足以确保强有力的隐私保护。</p>
<h4 id="llm推理中效用与隐私的权衡">LLM推理中效用与隐私的权衡
</h4><p>此外，除了引入保护个人数据的方法外，还有一些研究关注了在与LLM交互时效用与私人信息之间的平衡。这些研究主要集中在LLM推理的两种情境。第一种情境中，LLM运行在商业API后面，仅依赖文本提示作为输入。保护机制通常包括在提示或其对应嵌入中引入随机噪声。该情境中的代表性研究包括DP-OPT[26]和InferDPT[5]。这些研究表明，随着隐私预算的减少，任务性能会下降。此外，DP-OPT还指出，利用更大的LLM可以显著缓解性能和隐私之间的权衡。在第二种情境中，LLM被分为两部分：较大的一部分部署在服务器上，较小的一部分部署在客户端。服务器和客户端协作训练这两部分LLM，在嵌入向量中加入随机噪声以保护隐私。该情境下的代表性研究包括TextObfuscator[4]和SAP[28]。这两项研究也展示了隐私与效用之间的微妙平衡。具体来说，随着随机化的增加，隐私增强，效用降低，反之亦然。这些研究的主要重点在于实证评估保密性与性能之间的平衡，而缺乏理论框架或LLM推理过程中效用与隐私平衡的数值评估。我们的研究旨在填补这一空白，通过提供理论分析和量化评估。</p>
<h2 id="on-protecting-the-data-privacy-of-large-language--models-llms-a-survey">On Protecting the Data Privacy of Large Language  Models (LLMs): A Survey
</h2><p>关于保护大语言模型（LLMs）数据隐私的调查</p>
<h3 id="摘要-9">摘要
</h3><p>大语言模型（LLMs）是复杂的人工智能系统，能够理解、生成和翻译人类语言。它们通过分析大量文本数据学习语言模式，从而能够执行写作、对话、摘要等语言任务。在处理和生成大量数据时，LLMs可能会泄露敏感信息，从而威胁到数据隐私。本文重点阐述与LLMs相关的数据隐私问题，以促进对这一问题的全面理解。具体而言，本文对数据隐私威胁进行了深入研究，涵盖了LLMs中的被动隐私泄露和主动隐私攻击两个方面。随后，我们评估了LLMs在不同阶段采用的隐私保护机制，并对其效果和局限性进行了详细审查。最后，讨论了在LLM隐私保护领域面临的挑战，并概述了未来可能的研究方向。</p>
<h3 id="引言-7">引言
</h3><p>近年来，大语言模型（LLMs）已成为人工智能领域的关键角色，正在革新自然语言处理[1]、具身AI[3]–[5]、人工智能生成内容（AIGC）[6]、[7]等多个领域。LLMs通过在海量数据集上进行训练，具备了生成类人文本、回答复杂问题以及执行各种语言相关任务的非凡能力，且其准确性和流畅性前所未有。然而，在LLMs强大能力的背后，数据隐私问题引起了越来越多的关注[8]。一方面，LLMs可能面临被动隐私泄露的风险。用户若在聊天界面输入敏感数据，可能会无意间暴露这些信息给ChatGPT。例如，三星电子曾在三次不同的事件中，通过ChatGPT无意间泄露了公司敏感数据。此外，LLMs通常依赖大量数据进行训练，这些数据包括从互联网抓取的文本、公开可用的数据集或专有来源。这一数据聚合过程可能会引发重大的数据隐私问题，特别是在处理敏感信息或个人可识别信息（PII）时[9]。已有研究表明，LLMs可能会记忆训练数据，这引发了关于在推理过程中无意间泄露敏感信息的担忧[10]。即使采用差分隐私或联邦学习等技术来缓解训练过程中的隐私风险，模型参数中仍可能残留敏感数据的痕迹[11]。另一方面，LLMs也可能面临主动隐私攻击。将经过微调的LLMs部署到各种应用中，带来了额外的安全挑战。对预训练LLMs进行微调或适配特定任务，可能无意中暴露其漏洞，使其易于受到攻击，进而危及敏感信息的机密性、完整性或可用性[12]。例如，为了绕过模型固有的对齐机制，研究人员设计了一种提示策略，诱导GPT-3.5-turbo“偏离”产生常规响应，转而输出训练数据[13]。如后门攻击、成员推断攻击和模型反演攻击等已存在的漏洞，可以对预训练或微调后的模型进行利用，目的是非法获取敏感数据。为了展示当前的研究现状，我们在图1中概述了关于LLMs隐私保护的研究现状。考虑到关于隐私保护的学术论文和Hugging Face的模型列表，我们编制了该图中的流行LLMs列表。时间轴代表模型发布的日期，纵轴表示模型参数的大小。蓝色数据点表示文献中关于隐私保护关注较少的LLMs，而黑色数据点表示在隐私保护方面进行了研究的模型。目前，学术界对LLMs数据隐私的关注主要集中在相对较小的、知名的模型上，如2020年前版本的GPT-2[14]和BERT[15]系列。相比之下，近年来发布的具有更大参数规模的LLMs由于部分模型未公开发布，且隐私保护技术滞后于LLMs的快速发展，尚未得到充分审视。</p>
<p>在本文中，我们深入探讨了大语言模型（LLMs）中的数据隐私问题，特别是从隐私泄露和隐私攻击两个方面研究潜在的隐私威胁。此外，我们还研究了相应的对策，通过全面回顾LLMs开发的三个主要阶段：预训练、微调和推理，提出了相应的隐私保护措施。我们的贡献总结如下：
• 我们对学术文献中关于LLMs隐私威胁进行了全面调查，并将其分为两大类：隐私泄露和隐私攻击。
• 我们的研究包括对应用于LLMs的隐私保护方法的分析，并根据开发阶段将其分类。我们根据其所在阶段将隐私保护方法分为三组：预训练、微调和推理。在每个类别中，我们介绍了高层次的技术，解释了它们在LLMs中的应用，并提供了详细的文献回顾。我们调研的目标是为LLM开发者提供实施前沿技术的指导，以保护LLMs的隐私。</p>
<h3 id="相关工作-3">相关工作
</h3><p>在本节中，我们首先介绍了现有关于LLMs开发和评估的调查研究。然后，进一步阐述了与LLMs中的隐私和安全问题最相关的工作，最后总结了我们调查的研究。</p>
<h4 id="a-llm评估的调查">A. LLM评估的调查
</h4><p>目前，一些研究已经对LLMs的开发和评估进行了调查。这些研究通常涵盖了LLMs的架构改进（如GPT系列、BERT、Transformers [16]–[22]）。例如，Li等人[16]聚焦于将LLM与智能个人助理（IPA）集成，以提高个人助手的能力。该研究深入探讨了这些代理的架构、能力、效率和安全性。Zhao等人[18]关注LLMs的四个关键方面：预训练、适配调优、利用和能力评估。它提供了LLMs的全面背景，包括术语和技术。Naveed等人[21]对LLMs进行了广泛的分析，涵盖了它们的架构、训练、应用和挑战。该研究详细探讨了LLMs的各个方面，如预训练、微调和评估，同时还讨论了LLMs在不同领域中的各种应用。Hadi等人[22]提供了LLMs的详细概述，讨论了它们的历史、训练和在医学、教育、金融和工程等领域的应用。该研究考察了LLMs的技术方面、挑战和未来潜力，包括伦理考虑和计算需求。为了理解LLMs在各种应用中的能力和局限性，一些研究进行了关于这些LLMs的全面测量[17]、[23]、[24]。Chang等人[17]对评估LLMs的方法和标准进行了全面分析，讨论了评估任务、数据集、基准和评估技术等各个方面。Guo等人[23]强调了在多个维度上全面评估LLMs的必要性，如知识和能力评估、对齐评估、安全考虑和在专业领域的应用。在[24]中，Liu等人研究了LLMs与人类价值观和社会规范的对齐情况，提出了一种详细的分类法，用于在多个维度上评估LLM的可信度，如可靠性、安全性、公平性、抵抗滥用能力、可解释性、遵守社会规范和鲁棒性。</p>
<h3 id="b-llm安全性和隐私的调查">B. LLM安全性和隐私的调查
</h3><p>由于LLMs的训练依赖于大量的数据，这些数据通常包括敏感信息，因此，LLMs面临着处理隐私和安全问题的挑战[8]，[25]–[32]。Yao等人[8]全面研究了LLMs的安全性和隐私问题，并从三个方面进行了广泛的文献综述：有益的安全应用（如漏洞检测、安全代码生成）、负面影响（例如，网络钓鱼攻击、社交工程）和漏洞（例如，越狱攻击、提示攻击），以及相应的防御措施。Li等人[25]深入探讨了LLMs中的隐私问题，分类了隐私攻击，并详细介绍了防御策略。该研究还探讨了增强LLMs隐私的未来研究方向。Neel等人[26]研究了与LLMs相关的隐私风险，关注诸如敏感数据记忆和各种隐私攻击等问题。它回顾了减缓技术，并强调了LLMs隐私研究的当前状态。然而，他们主要关注通过红队测试模型来突出隐私攻击。Marshall等人[27]和Al-Hawawreh等人[28]探讨了ChatGPT在网络安全领域的作用。它们的讨论强调了其在现实世界中的应用，如增强代码安全性和检测恶意软件。Qammar等人[29]提供了关于聊天机器人发展到ChatGPT的广泛概述，并讨论了它们在网络安全中的作用，突出展示了漏洞和潜在攻击。然而，可能在特定的网络安全解决方案和针对已识别漏洞及攻击的预防措施方面缺乏深度。Schwinn等人[30]全面分析了LLMs中的旧威胁和新威胁，提供了对不断发展的对抗性攻击和防御的见解。但由于其对广泛威胁的关注，可能忽视了对特定攻击方法或防御机制的深入细节。Derner等人[31]研究了与ChatGPT相关的特定安全风险，为更好地理解其漏洞做出了贡献。然而，它可能没有与其他模型或系统进行全面比较，限制了其对ChatGPT的研究范围。Shayegani等人[32]彻底检查了对抗性攻击暴露的LLMs漏洞，提供了对未来模型改进的宝贵见解。然而，重点放在对抗性攻击上，可能导致对其他类型的漏洞或更广泛的安全问题关注较少。与现有的调查相比，我们的研究专注于解决LLMs中的数据隐私问题，提供了关于隐私威胁和隐私保护技术的全面文献回顾。我们深入研究了在不同阶段为减轻隐私威胁所采用的对策，并对LLMs数据隐私中的当前挑战和未来研究方向进行了深入讨论，旨在为该领域提供指导和参考。</p>
<h2 id="privacy-in-large-language-models-attacks-defenses-and-future-directions">Privacy in Large Language Models: Attacks, Defenses and Future Directions
</h2><p>随着深度学习和Transformer模型的进步，大语言模型（LLMs）显著提高了处理各种下游自然语言处理（NLP）任务的能力，并将这些任务统一到生成式管道中。一方面，强大的语言模型通过在海量文本数据上进行训练，为模型和用户带来了前所未有的可访问性和可用性。这些LLMs大大降低了应用开发者和用户的门槛，因为它们提供了预训练的语言理解和指令跟随能力。强大的LLM的可用性为各个领域开辟了新的可能性，包括LLM驱动的代理、虚拟助手、聊天机器人等。另一方面，开放访问这些模型也可能引发潜在的恶意和非故意的隐私风险。使这些模型成为有价值工具的能力，同样也可能被恶意利用或无意间泄露敏感信息。尽管目前有不断的努力来解决与LLM相关的安全和隐私问题，但这一问题仍未得到有效解决。</p>
<p>本文旨在深入探讨当前针对LLM的隐私攻击，并根据假设的对手能力对其进行分类，以揭示LLM中存在的潜在漏洞。接着，我们将探讨为减轻这些隐私攻击风险而制定的主要防御策略。除了讨论现有的研究成果，我们还将关注随着LLM不断发展，可能出现的隐私问题。最后，我们通过强调未来研究和探索的几条有前景的方向来总结本文。通过识别这些研究方向，我们旨在激发隐私保护领域的进一步进展，并为这些强大LLM的安全与隐私意识发展做出贡献。通过这项综述，我们希望为LLM中存在的潜在漏洞提供宝贵的见解，从而强调在其开发和应用中解决隐私问题的重要性。</p>
<h3 id="引言-8">引言
</h3><h4 id="动机-1">动机
</h4><p>随着自然语言处理领域深度Transformer模型的发展，预训练语言模型（LMs）标志着自然语言处理及整个社会变革时代的到来。目前，生成式大语言模型（LLMs）通过将各种自然语言处理任务结合成一个综合的文本生成框架，展现了卓越的能力。这些模型，如OpenAI的GPT-4、Anthropic的Claude 2和Meta的Llama 2，在理解和生成自然语言方面在近年来取得了重大突破。因此，这些LLMs在既定任务和实际挑战上均达到了前所未有的表现[19, 26, 49, 118, 187, 188, 211]。除了在各种应用中生成连贯且具有上下文相关性的文本外，LLMs还可以自动化许多语言相关的任务，使其成为开发者和终端用户不可或缺的工具。此外，LLMs具备广泛概括能力，可以处理大量未见过的文本语料。通过适当的指令（提示）和示范，LLMs甚至可以适应特定的上下文或应对新任务，而无需进一步调优[38, 124, 218, 271, 323]。因此，将LLMs集成到各种应用中的趋势日益明显，从科学研究到智能助手，都在广泛应用。</p>
<p>除了增强的性能外，语言模型的训练数据规模也随着模型的增大而扩大。这些LLMs不仅在特定任务上对标注文本数据进行训练，还从互联网上获取大量的公共文本数据。与精心挑选的标注数据不同，从互联网上提取的自由形式文本往往数据质量较差，且可能无意中泄露个人信息。例如，与模型的简单互动可能会导致个人身份信息（PII）的意外传播[24, 106, 137, 166, 256, 328]。不幸的是，在没有相关个人知情或同意的情况下，不经意暴露PII可能导致违反现有隐私法律，如欧盟的《通用数据保护条例》（GDPR）和加利福尼亚州消费者隐私法案（CCPA）。此外，将多种应用集成到LLMs中已成为一种日益增长的趋势，旨在增强其知识基础能力。这些集成使得LLMs能够有效解决数学问题（如ChatGPT + Wolfram Alpha）、读取格式化文件（如ChatPDF），并通过搜索引擎（如New Bing）回答用户查询。当LLMs与像搜索引擎这样的外部工具结合时，新的特定领域的隐私和安全漏洞也会出现。例如，Li等人[137]报告指出，恶意攻击者可能会利用New Bing，将受害者的PII与部分信息关联起来。因此，目前LLMs中隐私泄露的程度仍然不确定。</p>
<h4 id="范围与目标"><strong>范围与目标</strong>
</h4><p>本调查研究了大语言模型（LLMs）在隐私攻击和防御方面的最新进展。与几篇近期关于LLMs隐私的调查论文[18, 43, 113, 183]相比，我们的工作提供了更全面和系统的分析。我们不仅涵盖了先前调查的内容，还整合了大语言模型领域的最新进展，确保我们的分析是最新的并且具有相关性。此外，我们还探讨了新兴的隐私保护技术和策略，如差分隐私[67]、基于密码学的方法[181]、反学习和联邦学习[125, 140, 284]。通过评估这些防御机制，我们旨在提供关于它们有效性和局限性的有价值见解。最后，在分析了攻击和防御之后，我们讨论了未来尚未研究的隐私漏洞以及可能的解决方案。</p>
<h2 id="privacy-preserving-prompt-engineering-a-survey">Privacy Preserving Prompt Engineering: A Survey
</h2><p><strong>隐私保护提示工程：一项综述</strong></p>
<h3 id="摘要-10"><strong>摘要</strong>
</h3><p>预训练语言模型（PLMs）在解决广泛的自然语言处理（NLP）任务方面展现了显著的能力。研究人员发现，这些模型的性能与其规模之间存在直接的相关性。因此，近年来这些模型的规模显著扩大，促使研究人员采用“大语言模型”（LLMs）一词来描述较大规模的PLMs。规模扩展带来了一个独特的能力——上下文学习（ICL），这是一种特殊形式的提示方法，通过展示示例来使用模型，而无需修改模型参数。尽管这一特性非常有趣，但隐私问题已成为其广泛应用的主要障碍。多项研究已经考察了与ICL和提示技术相关的隐私风险，并提出了缓解这些风险的技术。因此，有必要整理这些缓解技术，以便为社区提供帮助。本综述系统地概述了在ICL和提示过程中采用的隐私保护方法。我们回顾、分析并比较了这一范式下的不同方法。此外，我们总结了可用于开发这些框架的资源。最后，我们讨论了这些框架的局限性，并详细探讨了需要进一步研究的有前景的领域。</p>
<h3 id="引言-9"><strong>引言</strong>
</h3><p>近年来，预训练语言模型（PLMs）的进展在各种自然语言处理（NLP）任务中展现了显著的能力，如文本分类、问答、情感分析、信息检索、摘要等[1]–[4]。其中，许多模型近期被推出，并持续获得显著的关注。例如，OpenAI的ChatGPT[5]用户数量已超过1.8亿[6]。其他常见的先进模型包括Meta的LLaMA[7]、OPT[8]、OPT-IML[9]、BigScience的BLOOM[10]、BLOOMZ[11]、Databricks的Dolly[12]等。通常，这些模型非常庞大，参数量达到数百亿，需要大量的计算资源用于训练和存储。术语“大语言模型”（LLMs）用于描述这些大规模的PLMs[13]–[15]。此外，这些模型主要通过使用来自网络、书籍、维基百科等多种开放文本资源进行预训练。本文中，我们将交替使用PLMs和LLMs这两个术语。</p>
<p>虽然通用型LLMs在理解和解决一般NLP任务方面表现出了优异的能力，但在处理领域特定任务和适应特定目标时，它们有时需要更深入和更精细的处理。为使模型适应领域特定的下游任务并调整其目标，已提出了调整可学习模型参数的微调技术[16]–[18]。然而，模型微调过程中常常伴随高计算资源需求、过拟合风险、灾难性遗忘以及模型稳定性等挑战[19]。因此，在进行微调时需要谨慎。其他模型适应技术包括指令微调、提示微调、对齐微调等[20]。</p>
<p>LLMs的新兴能力之一是提示（Prompting）。通过提示，LLM可以在提供自然语言指令和/或示范示例时生成预期的输出，而无需更新模型参数。最简单的提示类型是直接提示（也称为零-shot），用户通过提问的方式给出指令，并且不提供任何示例。上下文学习（ICL）是另一种提示形式，随着GPT-3的推出而提出[1]，它在提示中包括一些示范示例。ICL作为一种高效的方式，能够利用预训练或已适应的LLMs解决各种下游任务，而无需针对每个任务修改模型参数。然而，前述LLM使用技术不可避免地涉及可能被视为私人且包含敏感信息的数据。例如，考虑使用ICL预测一个人年收入是否至少为50,000美元。为了帮助LLM形成上下文并做出更好的预测，它可能会收到一个包含敏感信息的示范示例，如年龄、薪水和社会安全号码（SSN）。这种敏感信息可能会被不可信的LLM服务器或能够绕过LLM服务提供商API的对手访问。此外，由于Redis客户端开源库中的漏洞[21]，ChatGPT泄露了用户的聊天记录。</p>
<p>尽管隐私挑战，如训练或微调数据的记忆化及其通过模型反演和成员推断攻击的恢复[22]–[24]，已被注意到[25]，但这些挑战与ICL所带来的隐私问题本质上不同。因此，专门解决与ICL相关的隐私挑战以及一般提示的隐私问题，已成为迫切的任务。</p>
<h2 id="rhombus-fast-homomorphic-matrix-vector-multiplication-for-secure--two-party-inference">Rhombus: Fast Homomorphic Matrix-Vector Multiplication for Secure  Two-Party Inference
</h2><p><strong>Rhombus：用于安全双方推理的快速同态矩阵-向量乘法</strong></p>
<h3 id="摘要-11"><strong>摘要</strong>
</h3><p>我们提出了Rhombus，一个新的安全矩阵-向量乘法（MVM）协议，适用于半诚实的双方设置，能够无缝集成到现有的隐私保护机器学习（PPML）框架中，并作为线性层中安全计算的基础。Rhombus采用基于RLWE的同态加密（HE）与系数编码，允许消息从不仅仅是域 FpF_p 中选择，也可以从环 Z2lZ_{2^l} 中选择，后者支持在非线性层中进行更快速的计算。为了实现更好的效率，我们开发了一种输入输出打包技术，减少了由于HE与系数编码引起的通信成本约21倍，并提出了一种分割点选择技术，将旋转次数减少到矩阵维度的子线性级别。与Balla和Koushanfar（CCS'23）提出的最新协议HELiKs相比，我们的实现证明Rhombus使得整个MVM协议的性能提高了7.4倍至8倍，并将ResNet50的安全双方推理的端到端性能提升了4.6倍至18倍。</p>
<h3 id="引言-10"><strong>引言</strong>
</h3><p>机器学习（ML）已促成了众多应用的实现。特别是，模型所有者可以为用户提供推理服务，而用户无需具备训练模型的能力，即所谓的机器学习即服务（MLaaS）。用户能够从机器学习服务中获得价值，同时模型所有者也能有效地将其服务货币化。然而，MLaaS带来了一个关于数据隐私的挑战性问题，即模型所有者可能会了解到用户的私人数据，或者用户可能会泄露模型。隐私保护机器学习（PPML）通过提供安全的双方推理解决方案，来应对这一挑战性问题（即两方可以协作进行安全推理，而无需揭示数据隐私）。同态加密（HE）是一种强大的加密原语，它使得模型所有者能够对加密的用户数据进行复杂计算。尽管已经做了很多努力[KKK+22, SFK+22, LKL+22]以提高基于HE的计算效率，但由于模型所有者必须调用非常计算密集的引导操作，仍然无法在加密数据上执行所有推理计算。因此，许多协议（例如[MZ17, LJLA17, JVC18, SGRP19, ASKG19, CGR+19, DEK19, RSC+19, MLS+20, RRK+20, KRC+, NC21, RRG+21, PSSY21, HJSK21, CZW+21, HLHD22, RBS+22, SDF+22, HLC+22, RBG+23, HLL+23, GJM+23, BK23]）已经被开发出来，以提高在结合HE和安全多方计算（MPC）技术的混合框架下执行PPML的效率。</p>
<p>一个ML模型由一系列线性和非线性层组成。具体来说，线性层中的操作，例如3D卷积和全连接（FC），通常可以建模为矩阵-向量乘法（MVM），这些操作可以通过基于环学习误差（RLWE）的HE实现[ LPR10]，如先前的工作[ MZ17, JVC18, MLS+20, RRK+20, CZW+21, HLHD22]所述，而非线性层中的计算则通过基于秘密共享的MPC执行。因此，在这个混合HE-MPC框架下，每次使用HE执行MVM时，密文结果需要转换为秘密共享，以便进行非线性层中的后续计算，因此，乘法深度仅为1，且不需要引导操作。图1展示了一个基于HE的两方MVM范式，其中模型所有者（Bob）持有矩阵 W，而用户（Alice）持有向量 v，协议输出一个关于 $W \cdot v$ 的加法秘密共享向量(r1, r0)，使得 $r0 + r1 = W \cdot v$。</p>
<p>RLWE（环学习误差）基础的HE实现MVM协议有两种编码方法：（1）NTT编码，将数论变换（NTT）应用于原始数据，然后将其映射到明文多项式的系数上；（2）系数编码，直接将原始数据映射到明文多项式的系数上。大多数先前的工作[ JVC18, RRK+20, ZXW21, BK23, PZM+23] 设计了基于HE的MVM协议，采用了NTT编码。然而，NTT编码有三个缺点。首先，与系数编码相比，NTT编码的代价更高。其次，NTT编码仅限于在域 $F_p$ 上操作。如[RRK+20]所示，在 $F_p$ 上，基于OT（盲传输）的非线性层协议的通信成本大约比在环 $Z_{2^l}$ 上高1.5倍，其中 $p \approx 2^l$。第三，当将同态计算结果转换为加法秘密共享时，必须选择更大的HE参数，以保护在同态操作中使用的秘密值的隐私。最近的PPML协议Cheetah[HLHD22]采用系数编码来克服这些缺点，代价是引入了一个一位错误到计算结果中，但这对推理准确性没有影响，因为结果始终会被截断。然而，Cheetah将MVM或3D卷积结果编码为多个密文（每个密文仅编码结果的几个元素），这会带来较大的通信开销。特别地，点卷积（1×1滤波器大小）会给Cheetah带来较大的通信开销，占所有卷积安全推理中80%的开销，尤其是在ResNet50[HZRS15]这一流行深度神经网络（DNN）的推理中。这导致Cheetah在线性层的通信开销大于使用NTT编码的HE的最新PPML协议[ BK23]。如上所分析，我们在本工作中关注系数编码。在明文中，MVM可以视为矩阵每行与向量之间的内积。每个内积的计算通过将矩阵行和向量的元素分别放入两个独立的多项式中，然后进行相乘来实现。基于此，一种简单的做法浮现出来：Alice将她的向量 v 依次编码为一个多项式的系数，进行加密后，将密文发送给Bob。在接收到密文后，Bob将矩阵的每一行编码为明文多项式的系数，顺序上有些反转，然后将加密的向量与每一行编码后的数据相乘。结果，Bob为一个 $r \times c$ 矩阵生成 r 个加密多项式。为了实现 O(1) 的通信复杂度，Bob通过调用打包技术（即PackLWEs[CDKS21]）将 r 个密文打包成一个密文，但代价是需要进行 r - 1 次同态旋转。总之，简单的做法需要 O(r) 次明文-密文乘法和旋转。</p>
<h2 id="secformer-fast-and-accurate-privacy-preserving-inference-for-transformer-models-via-smpc">SecFormer: Fast and Accurate Privacy-Preserving Inference for Transformer Models via SMPC
</h2><p>SecFormer：通过SMPC实现快速准确的隐私保护推理用于Transformer模型</p>
<h3 id="摘要-12"><strong>摘要</strong>
</h3><p>随着Transformer模型在云平台上提供推理服务的广泛应用，隐私问题日益严峻，特别是涉及敏感数据如投资计划和银行账户详情。安全多方计算（SMPC）作为保护推理数据和模型参数隐私的有前景的解决方案应运而生。然而，SMPC在Transformer模型的隐私保护推理（PPI）中的应用常常导致显著的性能下降或速度减慢。这主要是由于Transformer架构中的大量非线性运算，这些运算不适合SMPC，并且很难有效地绕过或优化。为了解决这一问题，我们提出了一个全面的PPI框架，称为SecFormer，以实现Transformer模型的快速和准确的PPI。我们成功消除了PPI中高成本的指数和最大值操作，而不牺牲模型性能，并通过采用合适的数值计算方法开发了一系列高效的SMPC协议，提升了PPI中其他复杂的非线性函数的性能，包括GeLU、LayerNorm和重新设计的Softmax。我们的广泛实验表明，SecFormer在性能上优于MPCFormer，对于BERTBASE和BERTLARGE分别提高了3.4%和24.7%。在效率方面，SecFormer比PUMA分别快了3.57倍和3.58倍，展示了其高效性和速度。代码可通过点击此处获得。</p>
<h3 id="引言-11"><strong>引言</strong>
</h3><p>Transformer模型（Vaswani等，2017；Devlin等，2019；Radford等，2019；Brown等，2020；Raffel等，2020；Liu等，2019；Lewis等，2020；Zeng等，2021；Ouyang等，2022；OpenAI，2023）在多种下游任务中表现出色（Chan等，2024；Jiayang等，2023；Lu等，2019；Zhang等，2020；Lu等，2020；Liu等，2020；Zhang等，2023c；Wang等，2023），并广泛应用于“模型即服务”（MaaS）范式中，向客户提供高质量的推理服务。然而，这种MaaS框架对推理数据和模型参数构成了显著的隐私风险（Li等，2023b，c，d，2024；Zhang等，2024b；Zhang和Zhu，2020）。例如，基于Transformer的服务Copilot和ChatGPT要求用户上传明文请求。这一操作不仅对用户隐私构成威胁，还可能违反相关法律法规，如欧盟的《通用数据保护条例》（GDPR）。安全多方计算（SMPC）（Shamir，1979；Yao，1986；Goldreich等，1987）在保护推理数据和模型权重隐私方面表现出巨大潜力（Gilad-Bachrach等，2016；Liu等，2017；Mishra等，2020；Rathee等，2021；Huang等，2022；Luo等，2023；Zhang等，2023a，2024a）。然而，使用SMPC进行Transformer模型的隐私保护推理（PPI）证明特别缓慢。例如，BERTBASE（Devlin等，2019）在SMPC下进行单个样本推理需要71秒，而明文推理仅需不到1秒。这种低效源于当前SMPC协议在执行Transformer模型中的非线性运算时的局限性（见第2.2节）。如图1(a)所示，我们发现Softmax和GeLU占据了PPI时间的77.03%，尽管它们在明文推理中的开销所占份额较小。这个观察结果与Wang等（2022）；Li等（2023a）的研究一致。为了缓解这一问题，Li等（2023a）通过用一些SMPC友好的二次函数替代Softmax和GeLU，重新设计了Transformer模型，绕过了Softmax和GeLU中的非线性运算（如erf、指数和最大值）的隐私保护计算。这种激进的替代大大提高了PPI效率，但不幸的是，显著降低了模型的性能，并且对于更大的模型不可扩展（见图1(b)）。一些其他研究（Dong等，2023）尝试通过设计更高效的SMPC协议来提高PPI，虽然能够保持模型性能，但仍面临昂贵的PPI开销。</p>
<p>在本研究中，我们提出了一个全面的PPI框架——SecFormer，旨在通过利用Transformer模型和SMPC协议设计的优势，实现快速且准确的Transformer模型PPI。我们的研究表明，保留GeLU的精确计算显著提高了PPI性能（图1(b)）。基于这一见解，SecFormer通过模型设计绕过了Softmax中高开销的非线性PPI操作，如指数和最大值（第3.1节）。这种适应性调整结合了知识蒸馏的战略使用，使得SecFormer能够构建一个既高性能又兼容SMPC的Transformer模型。为了进一步提高PPI性能，我们转向协议设计，开发了一套高效的SMPC协议，利用适当的数值计算方法处理PPI中的其他复杂非线性函数，如GeLU、LayerNorm和重新设计的Softmax（第3.2节）。具体而言，SecFormer为GeLU引入了一种基于分段多项式和傅里叶级数的创新SMPC协议，促进了GeLU的高效准确计算。此外，SecFormer为LayerNorm和Softmax部署了高效的隐私保护平方根逆运算和除法计算，采用Goldschmidt方法（Goldschmidt，1964；Markstein，2004），并结合输入膨胀技术，绕过了非线性初始值计算。我们在多个数据集上对SecFormer进行了广泛的评估，使用Transformer模型BERTBASE和BERTLARGE。实验结果表明，与基于纯模型设计的最新方法相比，SecFormer在BERTBASE和BERTLARGE上的平均性能提升分别为3.4%和24.7%（第4.2节），同时保持了相当的效率。与仅改进SMPC协议的方法相比，SecFormer在PPI中实现了3.57倍和3.58倍的加速（第4.3节），同时维持了相当的PPI性能。</p>
<h3 id="背景与相关工作"><strong>背景与相关工作</strong>
</h3><h4 id="基于smpc的模型推理工作流程"><strong>基于SMPC的模型推理工作流程</strong>
</h4><p>安全多方计算（SMPC）是一种加密技术，为多个参与方之间的模型隐私保护推理（PPI）提供了有前景的解决方案（Gilad-Bachrach等，2016；Liu等，2017；Mishra等，2020；Rathee等，2021；Huang等，2022）。通常，参与方遵循诸如秘密共享（Shamir，1979；Goldreich等，1987）等加密原语来保护模型权重和推理数据。本文主要介绍了2-out-of-2秘密共享方案，因其效率高且具有代表性。具体而言，2-out-of-2秘密共享将一个秘密x分割成两个随机份额[[x]] = ([x]₀, [x]₁)，其中x = (([x]₀ + [x]₁) mod L)，确保每个份额都不会泄露关于x的信息，同时在两个份额结合时能够正确重构x。在构建SMPC协议时，份额由两个不同的参与方持有。它们相互传递掩蔽的中间结果，完成不同函数的隐私保护计算，并获得计算结果的份额。基于2-out-of-2秘密共享的PPI工作流程如图2所示，涉及三个主要利益相关者：需要保护模型权重的模型推理服务提供者、需要保护推理数据的客户端，以及执行模型PPI的SMPC引擎。SMPC引擎包含三个非共谋服务器（即参与者）：两个计算服务器Sᵢ（i ∈ {0, 1}），用于计算PPI的份额；以及一个辅助服务器T，用于生成执行SMPC协议所需的随机数。</p>
<p>初始时，服务提供者和客户端将模型权重和推理数据的份额分别安全地传输给S₀和S₁（步骤1和2）。随后，计算服务器利用这些份额作为输入，并通过与T的交互计算执行SMPC协议，完成PPI，最终生成推理结果的份额（步骤3）。这些份额随后被转发给客户端（步骤4），以便客户端在本地重构推理结果（步骤5）。由于每个参与者仅拥有输入、输出或中间结果的一个份额，因此该PPI工作流程能够保证模型权重和推理数据的隐私。</p>
<h4 id="基于smpc的transformer模型推理的主要瓶颈"><strong>基于SMPC的Transformer模型推理的主要瓶颈</strong>
</h4><p>尽管上述PPI工作流程能够保证模型权重和推理数据的隐私，但在实现一些非线性操作（即Softmax、GeLU和LayerNorm）时，面临不可接受的通信开销（见表1），这些操作在Transformer模型中大量存在，并成为PPI的主要瓶颈。具体来说，对于一个向量 $x = (x_1, x_2, \dots, x_n)$，Transformer中的Softmax将其转换为一个n维的概率分布，计算公式为：</p>
<p>$\text{Softmax}(x)[i] = \frac{e^{x_i - \tau}}{\sum_{h=1}^{n} e^{x_h - \tau}},$</p>
<p>其中 $\tau = \max_{h=1}^{n} x_h$ 用于确保数值计算的稳定性。如表1所示，Softmax的SMPC计算面临三个主要障碍：指数运算、除法和最大值运算。需要注意的是，最大值的计算需要调用ΠLT操作logn次（Knott等，2021），因此成为最大的障碍。</p>
<p>GeLU的函数定义为：</p>
<p>$\text{GeLU}(x) = x \cdot \frac{1}{2} \left( 1 + \text{erf}\left(\frac{x}{\sqrt{2}}\right) \right),$</p>
<p>其中 $\text{erf}(x) = \frac{2}{\sqrt{\pi}} \int_0^x e^{-t^2} dt$。GeLU函数的非线性部分源自$\text{erf}$，目前没有现成的SMPC协议用于其隐私保护计算。</p>
<p>对于一个向量 $x = (x_1, x_2, \dots, x_n)$，LayerNorm函数定义为：</p>
<p>$\text{LayerNorm}(x) = \gamma \cdot \frac{x - \overline{x}}{\sqrt{\text{var}(x) + \epsilon}} + \beta,$</p>
<p>其中 $\overline{x} = \frac{1}{n} \sum_{h=1}^{n} x_h$，$\text{var}(x) = \frac{1}{n} \sum_{h=1}^{n} (x_h - \overline{x})^2$，$\gamma$ 和 $\beta$ 是两个可学习的参数，$\epsilon$ 是一个非常小的常数，用于防止分母为零。对于SMPC而言，计算LayerNorm的主要瓶颈来自于除法和平方根运算。</p>
<h4 id="transformer模型的高效ppi"><strong>Transformer模型的高效PPI</strong>
</h4><p>为了缓解上述瓶颈，现有的Transformer模型PPI研究通过模型设计或SMPC协议设计提高效率。基于模型设计的研究（Chen等，2022；Li等，2023a；Zeng等，2022；Zhang等，2023b；Liang等，2023）通过替换Transformer中的非SMPC友好型非线性操作，绕过了PPI中的高开销操作。这些方案大幅提高了效率，但通常会导致模型性能显著下降。设计更高效SMPC协议的研究（Hao等，2022；Zheng等，2023a；Gupta等，2023；Dong等，2023；Hou等，2023；Ding等，2023；Pang等，2023）则通过为Transformer中的非线性操作定制高效的SMPC协议来提高PPI效率。这些方案保持了Transformer模型的性能，但仍然面临着高昂的计算和通信开销。</p>
<p>作为基于模型设计的代表性工作，Li等（2023a）通过将GeLU和Softmax分别替换为$ \text{Quad} = 0.125x^2 + 0.25x + 0.5$ 和
</p>
$$
2\text{Quad}(x)[i] = \frac{(x_i + c)^2}{\sum_{h=1}^{n} (x_h + c)^2},
$$<p>
从而绕过了erf、指数和最大值的隐私保护计算。在此基础上，采用了知识蒸馏，细调后的Transformer模型作为教师，近似Transformer模型作为学生，蒸馏过程在下游任务数据上进行，从而得到一个与SMPC兼容的Transformer模型。该方法在提高PPI效率方面有效，但会导致模型性能显著下降。我们的研究表明，保持GeLU的准确计算显著提高了PPI性能。Dong等（2023）通过利用分段函数和多项式拟合，首次为GeLU函数提出了SMPC协议。然而，分段函数和多项式的计算需要多次调用ΠLT和ΠMul，导致其效率较低。</p>
<h2 id="secure-transformer-inference-protocol">Secure Transformer Inference Protocol
</h2><p><strong>安全Transformer推理协议</strong></p>
<h3 id="摘要-13"><strong>摘要</strong>
</h3><p>对于基于Transformer的服务（如ChatGPT），模型参数和用户数据的安全性至关重要。尽管近期在安全双方协议方面取得了进展，成功解决了Transformer模型服务中的安全问题，但由于加密开销过于庞大，其在实际中的应用仍然不可行。通过在开发两个真实世界的基于Transformer的服务过程中的实践经验，我们识别出了双方假设中固有的效率瓶颈。为了克服这一限制，我们提出了一种新颖的三方威胁模型。在该框架内，我们设计了一种半对称的基于置换的保护方案，并提出了STIP，这是首个在推理准确性不丢失的情况下实现安全Transformer推理的协议。在真实系统中对代表性Transformer模型的实验表明，STIP在安全性上具有实际可行性，并且在效率上比现有的安全双方协议高出数百万倍。</p>
<h3 id="引言-12"><strong>引言</strong>
</h3><p>基于Transformer的推理服务是最前沿的人工智能应用[13, 23, 44]。云计算能力，如自动扩展[45]，满足了为Transformer提供服务的需求，尤其是具有数十亿参数的大型模型。因此，像OpenAI这样的主要组织选择将其基于Transformer的服务完全部署在云端[5]。然而，在隐私敏感领域，将原始数据发送到云端是不可行的，例如三星禁止使用ChatGPT后的敏感代码泄漏事件[21]。
<strong>模型拆分不够安全</strong>
模型拆分推理[30, 50, 58]通过在设备和云端之间战略性地分配神经网络层，设备将中间激活值发送到云端以继续推理。模型拆分推理避免了原始数据的传输，同时保持了效率[38, 39]。然而，研究表明，存在从中间激活值逆向工程敏感信息的潜在风险[2, 37]。
<strong>安全的双方协议产生高昂开销</strong>
近期研究探讨了通过同态加密（HE）和安全两方计算（2PC）[11, 24, 26]进行安全的Transformer推理。然而，这些协议会带来高昂的计算和设备-云端通信开销，尤其是在复杂的非线性层（如LayerNorm和ReLU）上。例如，CipherGPT使用GPT2模型生成单个token时需要25分钟的处理时间和90GiB的流量[26]。
<strong>第一性原理思维：三方威胁模型</strong>
为了克服效率瓶颈，我们使用第一性原理重新思考基本的两方假设：模型所有者和数据所有者。通过管理两个真实世界的基于Transformer的服务1，我们总结出一个一致的经验：模型开发者 ≠ 模型服务商。在这两个服务中，我们通过对开源参数[33, 51]进行微调[27]，利用收集的数据开发了Transformer模型。我们具备足够的计算能力进行离线模型开发，但缺乏为数十万用户提供大规模、长期服务的能力。因此，作为模型开发者，我们依赖第三方云平台提供模型服务。基于我们的实际开发经验，我们提出了一种新的三方威胁模型。在这个模型中，我们将模型所有者分解为两个实体：模型开发者和模型服务商。由于开发的模型是专有的，模型开发者必须保护其模型参数免受模型服务商潜在攻击[60]，因此我们假设他们不会串通。</p>
<p><strong>STIP的洞察与设计</strong>
基于我们提出的三方威胁模型，我们开发了STIP（Secure Transformer Inference Protocol），并从两个方面进行了设计。首先，我们采用高效的特征空间置换来实现安全且等效的Transformer推理。由于推理在不可信的服务器上执行，模型参数和设备上的数据必须在上传到云端之前进行转换。基于特征空间的高效置换，我们设计了一个Transformer层的数据和参数转换方法。我们证明了使用我们提出的转换方法进行计算在数学上是等效的，从而确保没有准确性损失。其次，我们设计了一个模型开发者与数据所有者之间的半对称保护方案。这一思路源于神经网络的顺序结构。我们揭示了模型开发者只需要与数据所有者共享第一层和最后一层的相同置换，并可以独占保留中间层转换的信息。类似的半对称保护方案已经在图像加密[16]和在线购物[20]等领域得到应用。我们通过距离相关性[49]证明了STIP的隐私保护能力，并证明它抵抗暴力破解和已知明文攻击。</p>
<p><strong>贡献</strong>
我们总结了本工作的三个关键贡献如下：</p>
<ul>
<li>我们识别了两方设置中固有的效率瓶颈及其与现实应用的错位问题。我们提出了一种新的三方威胁模型，将模型所有者分解为两个独立的实体：模型开发者和模型服务商。</li>
<li>我们提出了STIP，这是第一个针对三方Transformer推理的安全协议，具有隐私泄露的理论界限并保证没有准确性损失。</li>
<li>我们实现了STIP，并在真实系统中对多种具有高达700亿参数的Transformer模型进行了评估。实验结果展示了STIP的效率，接近未保护的全云推理，并超越了现有的安全两方协议[11, 24, 26]数百万倍。</li>
</ul>
<p>本工作没有提出任何伦理问题。</p>
<h2 id="truncformer--private-llm-inference-using-only-truncations">TRUNCFORMER:  PRIVATE LLM INFERENCE USING ONLY TRUNCATIONS
</h2><p>&ldquo;TRUNCFORMER: 仅使用截断的私有LLM推理&rdquo;</p>
<h3 id="摘要-14"><strong>摘要</strong>
</h3><p>私有推理（PI）在与专有机器学习模型（如大语言模型（LLM））交互时，发挥着保障用户数据隐私的重要作用。然而，由于LLM中非线性函数带来的巨大延迟成本，PI在实践中仍然难以实现。现有的研究工作主要集中在通过近似方法提高特定LLM非线性函数（如Softmax或GeLU）的延迟性能。然而，随着新的LLM架构不断推出，新型非线性函数也随之出现，这导致PI研究者不断追赶，试图优化最新的非线性函数。我们提出了TruncFormer，一个将任何LLM转化为纯文本模拟PI的框架。我们的框架利用了LLM中非线性函数可微分的事实，这些非线性函数可以通过一系列加法、乘法和截断操作来准确近似。此外，我们将加法/乘法和截断操作解耦，并根据给定的字段大小和输入表示大小静态地确定应该在哪些地方插入截断操作。与现有的加密协议（这些协议在每次乘法操作后强制执行截断）相比，这种方法可以带来延迟性能的改进。我们将代码开源，供社区使用。</p>
<h3 id="引言-13"><strong>引言</strong>
</h3><p>近年来，基于变换器（transformer）的巨大语言模型（LLM），如ChatGPT的常规使用量急剧增加。许多这样的模型是专有的，通过API调用进行访问，用户需要将输入数据（如提示或其他上下文）发送给模型提供者以获取推理结果。因此，当查询涉及机密数据时，这些模型不可用。克服这一问题的一种方法是使用私有推理（PI）与安全多方计算（MPC）。PI是一种使用加密技术执行机器学习推理的过程，其中数据持有者和模型所有者都无法得知对方的数据。尽管在许多先前的工作中已经展示了使用MPC进行PI的可能性，但由于高延迟成本，PI的实际可行性仍然存在争议（Evans等，2018；Liu等，2017）。从宏观上看，PI的延迟成本可以分为两个部分：字段内操作和字段外操作。传统的加密操作是在固定大小的字段中执行的，这些字段仅支持加法和乘法。这些操作比明文版本的操作要慢，但并不是PI延迟的主要原因（Ghodsi等，2020）。字段外操作，如除法、指数运算、ReLU等，是PI中延迟的主要来源，因此，现有的大多数PI协议都必须使用诸如Yao的加密电路（Yao，1986）或盲传输（Kilian，1988）等技术。然而，这两种技术都非常依赖通信，因此会显著增加实际PI实现的延迟。</p>
<p>为了应对字段外PI操作带来的巨大延迟，出现了大量相关的研究工作。早期的工作如Delphi（Mishra等，2020）和Circa（Ghodsi等，2021）为字段外操作创建了多项式近似。随后，像CryptoNAS（Ghodsi等，2020）、Sphynx（Cho等，2022a）、SNL（Cho等，2022b）和SE-Net（Kundu等，2023）等方法通过适应网络架构来最小化字段外操作的数量。然而，这些方法大多考虑了涉及卷积/残差网络的计算机视觉应用，主要关注ReLU作为唯一的字段外操作。</p>
<p>随着LLM和变换器架构的兴起，PI方法现在不得不应对新的字段外操作类型。这导致了一小部分、但不断增长的研究工作，专注于优化特定的操作，如Softmax或GeLU。最近，MPCFormer（Li等，2022）、PriViT（Dhyani等，2023）、MPCViT（Zeng等，2022）、和Sal-ViT（Zhang等，2023）等方法采用了类似的网络适应思想，以减少在变换器模型中加密处理非线性操作的负担。其他相关的研究包括（Hao等，2022；Hou等，2023；Zheng等，2023）；详细综述见（Luo等，2024）。然而，由于LLM研究的快速进展，新的协议或针对非线性操作的PI友好型近似方法的竞争仍在不断进行。</p>
<h3 id="我们的贡献-1"><strong>我们的贡献</strong>
</h3><p>在本文中，我们提出了TruncFormer，一个用于LLM推理的新框架，可以与任何网络架构和任何PI协议结合使用。具体而言：</p>
<ol>
<li>TruncFormer接收任意变换器模型，并根据给定的字段大小和算术操作的位宽，静态地确定在可能发生溢出的地方计算截断。</li>
<li>TruncFormer修改了各种Crypten（Knott等，2021）对字段外操作的近似，使其适用于当今的公开LLM。</li>
<li>将这些内容结合起来，我们展示了TruncFormer仅通过字段内操作（加法/乘法）和截断操作，完成了LLM的私有推理。</li>
<li>我们使用一个纯文本库验证了TruncFormer，该库准确模拟了在PI环境下实现我们方法的成本（延迟和准确性），并测试了两个流行的LLM（Llama-7B和Gemma2B）。我们将该库开源，供社区使用（见 <a class="link" href="https://anonymous.4open.science/r/fixed_llm-D334/README.md"  target="_blank" rel="noopener"
    >https://anonymous.4open.science/r/fixed_llm-D334/README.md</a>）。</li>
</ol>

</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI&#43;WdtXRGWt2kTvGFasHpSy3SV"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG&#43;vnGctmUb0ZY0l8"crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05"crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.body, {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>
    
</article>

    

    

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2024 Zion Blaze
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.29.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>
<div id="particles-js"></div>

<script src=https://JiangZhiyu-1024.github.io/background/particles.min.js></script>
<script>
  particlesJS.load('particles-js', "https://JiangZhiyu-1024.github.io/background/particlesjs-config.json", function () {
    console.log('particles.js loaded - callback');
  });
</script>
<style>
  #particles-js {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    z-index: -1;
  }
</style>

<style>
  @font-face {
    font-family: 'PL';
    src: url(https://JiangZhiyu-1024.github.io/font/PL.ttf) format('truetype');
  }

  :root {
    --base-font-family: 'PL';
    --code-font-family: 'PL';
  }
</style>
    </body>
</html>
